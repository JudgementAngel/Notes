法线贴图
    红色通道里：白色表示法线向右偏，黑色表示法线向左偏
    绿色通道里：白色表示法线向下偏，黑色表示法线向上偏
    蓝色通道里：越黑表示越深

置换贴图
    
无意中看到这篇文章，含金量很高，待我慢慢给大家翻译。最近诸事不顺，所以我只能说尽快搞完，各位别催。

原文地址：http://www.cggallery.com/tutorials/displacement/
翻译：aboutcg\purplesun (转载请注明出处，否则生儿子两个屁眼)

ACCURATE DISPLACEMENT WORKFLOW
精确置换贴图制作及渲染流程

FROM: ZBRUSH / MUDBOX
TO: V-RAY for MAYA & 3DS MAX / ARNOLD for MAYA

这两段要是看不懂就去死好了。

置换贴图精华帖 
INTRO
介绍

This tutorial attempts to cover and clarify the process of generating and applying accurate displacement maps from either ZBrush or Mudbox, to V-Ray for Maya, V-Ray for 3ds Max, or Arnold for Maya.
本教学将向各位讲解在ZBrush 和 Mudbox里如何创建精确的置换贴图，以及如何在V-Ray for Maya, V-Ray for 3ds Max, 还有 Arnold for Maya里使用的过程和原理.

There's often a lot of confusion and misinformation surrounding displacement maps and how they're supposed to work. You'll sometimes see artists load a displacement map onto their low resolution geometry and play with intensity and depth values until it looks somewhat similar to their high resolution geometry and assume that's it's as close as they can get. But with a correct workflow you don't have to fiddle with settings or settle for 'close enough' - it'll just work correctly from the start to match your high resolution geometry as accurately as possible.
置换贴图的创建和使用常常把人搞晕，各位可能有时会看到一些艺术家为低模赋予置换贴图后，接着调整强度值和深度值，直到渲染结果看来比较接近高模的样子。但是只要使用正确的制作流程的话，各位就无需为了尽量“接近”高模的效果而胡乱的去调整各种参数。它会完完全全准确的还原各位的高模。


We'll cover some of the underlying concepts so you'll know how a floating-point displacement map works and how to recognize if you're getting correct results. We'll then cover some of the common pitfalls that artists frequently run across and how to avoid them. Then I'll provide the step-by-step procedures to make displacement mapping work accurately in your software of choice.
我们将讲解一些底层的概念（原理），这样你将明白浮点类型的置换贴图是如何工作的并且会搞清楚是否得到了正确的结果。我们还会讲到一些艺术家经常犯错的地方以及如何避免这些错误。接下来，我将一步一步的向各位演示如何让置换贴图准确的工作。


If you already know the underlying concepts and just want the technical step-by-step procedures, click here to skip right to it.

如果你已经知道一些基本的底层原理而只想了解具体每一步是如何做的，可以跳到后面的部分。

HOW FLOATING-POINT DISPLACEMENT WORKS
浮点类型置换贴图是如何工作的

Displacement mapping is a science. It's a method of taking high resolution geometry information and baking it to an image map that can be applied to low resolution geometry. This map then gets used by your renderer to replicate the high resolution geometry detail as accurately as possible. A properly generated floating-point displacement map will make your low res geometry match your high res geometry very accurately - right from the start.
置换贴图这东西是高科技，它是一种把高模的模型信息烘焙成一张贴图，然后赋予低模以后重新还原出高模细节的方法。正确制作的浮点置换贴图，可以完全还原你最初的高模。


This is because a correctly generated floating-point displacement map works in a very logical way: The displacement map's pixel values correspond directly to your 3D package's scene units. So a pixel value of 1.0 will displace your mesh by 1.0 scene units. A pixel value of 0.5 displaces your mesh by 0.5 scene units. And a pixel value of 0.0 doesn't displace your mesh at all. All very logical. And because the displacement map's pixel values are stored in floating-point format, they can contain pixel values far above 1.0, and negative pixel values far below 0.0. It's a great way to store precise displacement informati.
这是因为正确生成的浮点置换贴图以一种非常符合逻辑的方式工作：即置换贴图上的每一个像素的值均完全的和对应的的三维模型点的三维空间上的单位值一致。因此，置换贴图上的像素值1.0将会把对应的模型移动1个单位，置换贴图上的像素值0.5将会把对应的模型移动0.5个单位，当然置换贴图上的像素值0将不会有任何置换效果。所有的都很符合逻辑。并且由于置换贴图的像素值以浮点的方式储存的，因此这张置换贴图上的像素值就可能大于1或者小于0，这是储存置换信息的完美方法。


We can illustrate this using a simple test scene:
3 planes on different locations along the up/down axis, each made of just one polygon, and each with a default planar UV map.
The top plane is at 35.0 units on the up/down axis.
The middle plane is at 0.0 units on the up/down axis.
The bottom plane is at -20.0 units on the up/down axis.
我们可以通过一个简单的测试场景来描述这个问题：
三个面位于上下方向的不同位置上。每一个面都只由一个多边形组成，都是默认的 planar UV map。
最上面的平面的位置是正上方35个单位。
中间的面处于原点位置
最下面的平面的位置是正下方20个单位。 置换贴图精华帖
displacement_figure_01.jpg (52.16 KB, 下载次数: 0)
下载附件
2013-10-17 23:22 上传

FIGURE 01 Three identical planes located at different spots on the up/down axis.
Download this test setup in multiple formats if you want to try it yourself.
图片01 三个完全相同的平面放置于不同的高度，
如果你想自己试试，可以在这里下载：http://pan.baidu.com/s/11hKsB


We'll import the scene into a program like ZBrush or Mudbox, subdivide the middle plane a few times, and do some simple sculpting on it. First we'll pull a point in the center up just enough so it touches the plane above it, and then pull two points down on the sides until they just touch the plane on the bottom. We'll also write something across the surface for some additional detail.
我们把这个场景导入到zbrush或者mudbox，把中间那个面片细分几次，然后再做些简单的雕刻，首先移动模型中间的局域让它刚好碰到最上面的那个面。接着拖动两个位置的点让它们刚好碰到最下面的面。同时再加一些其他的细节再上面。
置换贴图精华帖
displacement_figure_02.jpg (60.51 KB, 下载次数: 0)
下载附件
2013-10-18 19:27 上传

FIGURE 02 The middle plane with sculpting applied to reach the top and bottom planes.
图片 02 雕刻中间的区域让他们碰到上面和下面的模型。

Once we're done, we can go ahead and generate the displacement map for the middle plane (using the procedure listed below). We can now open and inspect the map in a program like Nuke - which works natively with floating-point images.
完成以上操作后，我们就可以为中间的平面模型创建置换贴图了（具体方法参考后面的内容）。接着就可以在nuke之类（这类软件可以完美的处理浮点类型的贴图）的软件打开以及观察这张置换贴图了。

In the Nuke viewer we can test our generated displacement map. When we hover our cursor over the center point of the image - which corresponds to where we pulled up the mesh to touch the top plane - Nuke shows us a pixel value of roughly 35.0, which if you'll recall is exactly where we placed the top plane along the up/down axis. Also when we hover over the general location corresponding to either of the two points we pulled down, we see pixel values of roughly -20.0, also exactly where we placed the bottom plane along the up/down axis.
在nuke的视图中我们可以测试我们前面生成的置换贴图。当我们把鼠标的光标移动到这张图片的中心区域-此处就是我们拖动模型碰到做上面的面的区域。nuke所显示的数字会非常接近35.0，基本上就是我们顶端那个面片再上下方向上的距离值。同样，把光标移动到另外两个向下拖动的点的区域，显示的数字也会非常接近-20.0.同样和处于最下面的那个面距离值差不多。 置换贴图精华帖
displacement_figure_03.jpg (61.99 KB, 下载次数: 0)
下载附件
2013-10-18 19:28 上传

FIGURE 03 Hovering over points of the displacement map in the Nuke viewer shows their pixel values. Here the image is red because displacement only needs one channel to store its info - so it's stored in the Red channel. Also the negative pixel values are not directly visible because they are below 0.0 - the black point of our monitors.
图片 03 在nuke的视图区域移动光标，就会显示出光标所在位置的像素值。这里的图片显示出红色，是因为置换贴图的信息只需要一个通道来储存-所以就存在红色通道了。另外像素值小于0的区域在显示器上看到的都是黑色的。
While we might not be able to directly SEE much in the displacement map from a raw visual standpoint, the data it contains is certainly there... and

that's really all a displacement map is - an image being used to store displacement data.
当然直观的看这张贴图好像并没有上面特别之处，但是它确实包含了置换的数据。所有的置换贴图都是这样的—即通过图片的像素值来储存置换数据。


So we can assume that this is a correctly generated displacement map since we know ahead of time how high and low we placed the upper and lower planes along the up/down axis.  And sure enough when we apply the displacement map to the middle plane in our 3D software (using the procedure listed below) and hit render, we get the exact same result we had in our sculpting program - the center point just touches the top plane 35.0 units above it, the two points on the side just touch the bottom plane -20.0 units below it, and the rest of the details displace correctly. No 'displacement amount', 'shift', or 'middle point' settings had to be fiddled with - it correctly and accurately displaces the mesh right from the start.
因此我们可以认为这是一张准确生成的置换贴图，因为我们前面通过设置上下两个面片知道了相应位置的数值。理所当然的，当我们在三维软件（maya或者max，后面会有详细演示）打开中间这个面，并且赋予这张置换贴图的时候，点击渲染。我们就能完全还原在雕刻软件中的样子—即中间区域的点碰到上方35个单位平面位置，另外两个点碰到下方-20个单位的平面位置，其余部分也完全正确的显示出相关的细节。不需要胡乱的去调整诸如'displacement amount', 'shift', 或者 'middle point' 等参数。因为现在的结果已经和开始的时候完全一样了。


置换贴图精华帖
displacement_figure_04.jpg (50.07 KB, 下载次数: 0)
下载附件
2013-10-18 20:16 上传
FIGURE 04 The displacement map applied to the middle plane and rendered - exactly matching what we had in our sculpting program.
图片 04 为中间的平面赋予置换贴图并且渲染—完全和一开始在雕刻软件中的样子一样。

Even though this example uses fairly extreme values (35.0 units up and -20 units down) the results are still accurate. In another example we apply displacement to a more complex object with multiple UV seams and still get correct results - even across the seams. The boxes on the side of the sphere are 5 units wide on all sides, and serve as a visual indicator to confirm correct displacement amounts.
在这个例子中就算是使用了非常极端的值（向上35向下20），其结果也是非常的准确。再另外一个例子中我们为一个更加复杂的模型赋予了置换贴图，这个模型有多条uv接缝，最后的结果同样非常准确，即使是在接缝上。球体两边正方长宽高都是5个单位，作为一个指示器来证明置换结果的准确。
置换贴图精华帖
displacement_figure_05.jpg (68.46 KB, 下载次数: 1)
下载附件
2013-10-20 18:36 上传

FIGURE 05 Displacement mapping applied to a more complex object, with displacement occurring over multiple UV seams with no issues.
图片 05 为更加复杂的模型赋予置换贴图，并且是有多条uv接缝的情况的运行完美。

And finally, below is a example of floating-point displacement mapping in a real world production setting. The detailing you see on the right comes purely from displacement mapping - there are no normal or bump maps involved - and it matches the high resolution geometry of the original sculpt precisely.
最后，下面这个例子使用的是浮点置换贴图，使用的是写实的产品渲染设置。右边的图片你可以看到，那些细节完全来自于置换贴图-这里没有使用任何的法线贴图和凹凸贴图，并且其结果完全还原了再最初雕刻软件中的样子
置换贴图精华帖 
FIGURE 06 On the left: The basemesh without displacement mapping applied
On the right: The basemesh with displacement mapping applied.
图片 06 左边是没赋予置换贴图的样子，右边是使用置换贴图以后的效果。

COMMON PITFALLS & AVOIDING THEM
常见的问题 & 避免这些问题的出现

UVS ARE IMPORTANT
UVS 非常重要
Displacement mapping generally requires a good UV layout of your object. There can be no overlapping UVs as it will cause errors in the generated maps. Also, ZBrush in particular does not like UVs to rest directly on the edges of the UV sheet (as some automatic UV generation methods will do) - so make sure your UVs are always placed slightly within the edges of the UV sheet.
置换贴图的生成需要你的模型首先编辑好uv。uv不能有重叠，否则生成贴图的时候就会产生错误，另外zbrush尤其不喜欢uv放置在边框上（因为有些自动的uv编辑方法会这么干）所以确保你的uv要放在边框以内。注：这个边框就是说的0到1的uv空间。

DOUBLE CHECK YOUR BASEMESHES
一定要检测好你的基础模型
Remember that while sculpting at higher subdivision levels, the positions of lower subdivision vertices are often also being affected. So the low res mesh you imported into your sculpting program may no longer be exactly the same as the low res mesh you're using to generate your displacement map. Always double check to make sure the low res mesh you generated your displacement map from is the same as the mesh you're applying your displacement map to.
一定要记住当你在高细分级别雕刻的时候，低细分级别的模型同样会受到影响。所以，你最开始导入到雕刻软件雕刻的低模就会和你生成置换贴图的低模不一样了。一定要确保你渲染使用的低模要和你生成置换贴图的低模是同一个模型

FLOATING-POINT DISPLACEMENT MAPS ARE SCALE DEPENDENT
浮点置换贴图是基于模型的缩放尺寸的
Since the pixel values of a floating-point displacement map correspond directly to scene units, your object's scale becomes an important factor for guaranteeing accurate displacement amounts. If you scale your low-res mesh up or down after you've already generated your displacement map, your displacement map will no longer have accurate intensity values relative to the new scale of the basemesh. The map will either have to be regenerated with the new object scale, or compensated for by the 'Displacement Amount' setting in V-Ray, or displacement 'Height' setting in Arnold. For example: if you scaled your object up x2, then you'll have to increase the displacement amount setting x2 to compensate.
由于浮点置换贴图上的像素值是基于场景单位的，所以你的模型缩放储存将是影响渲染结果非常重要的因素。如果你在生成完置换贴图以后放大或者缩小了低模。那么你的置换贴图的强度值将不再准确了。这张置换贴图需要使用新缩放的模型的重新生成一张。或者在 V-Ray里面设置'Displacement Amount'参数。在Arnold里面设置'Height'参数。比如：如果你放大了模型两倍，就需要把相关参数也放大两倍来补偿。

FLOATING-POINT -VS- INTEGER
浮点-VS-整型
The procedures listed below cover generating 32bit floating-point displacement maps, but if you're in a production setting that's especially concerned about saving harddrive space, you can also use 16bit floating-point (half-float) and still get practically identical results. However it's important to be sure you use a 16bit floating-point format to store your image, and NOT a 16bit integer format. An integer format will not work correctly in this workflow, and you'll have to do the whole 'displacement amount' and 'shift' song and dance to make them work. This is because integer formats do not support negative pixel values, which are used by floating-point displacement maps to represent carved-in areas. If you're not sure how to get one or the other, stick to the procedures listed below to get 32bit floating-point displacement maps.
在本章最后所演示的是如何生成32位的浮点置换贴图。但是如果你制作中对文件大小有特殊的要求，你也可以使用16位的浮点置换贴图(half-float)并且也会得到几乎完全一样的结果。但是请注意了，你保存的是16位的浮点类置换贴图，而不是整型类置换贴图。整型类置换贴图在本次演示的制作流程中不能准确工作。如果你用整型类置换贴图的话，你就不得不又去调整 'displacement amount' 和 'shift'之类的参数。因为,整型类的贴图并不能储存负值，而必须使用浮点类的置换贴图来储存凹陷的区域（负值）。如果你不确定究竟使用哪一个。就严格安州后面的流程制作32位的浮点类置换贴图吧。


THERE'S ONLY SO MUCH DISPLACEMENT CAN RELIABLY DO
置换贴图并非万能
In an ideal world, floating-point displacement mapping always produces exact, accurate results with absolutely no differences from the original high resolution mesh. Unfortunately 3D software is hardly ideal - and each software package tends to have it's own methods to accomplish similar tasks. Where this can sometimes cause subtle shifts in precision for displacement is the topic of smoothing algorithms. Some software packages use an algorithm like
Catmull-Clark to smooth their meshes, and other packages use their own entirely different method. Until the day comes that all software packages can agree to use the same algorithms (like Pixar's OpenSubdiv initiative - email your software companies encouraging them to implement it!) there can be slight changes between your high res mesh to your displaced low res mesh. The good news is these shifts are often subtle and become much less of an
issue if your basemesh isn't VERY low polygon. Basically, don't expect displacement to be a magic bullet. If you're trying to turn a simple polygon cube into an apple through displacement mapping only, don't be surprised if you run into issues. Give your low polygon object proper form and polygon resolution, and let displacement carry the details.
在理想的世界中。浮点类置换贴图总能等到精确地结果，这个结果几乎和原始的雕刻模型没什么区别。悲剧的是，三维软件并不是很完美——每一个三维软件几乎都喜欢使用各自的方法来完成同样的事情（显得他们的高端大气上档次）。这样的话在使用置换贴图的模型在使用光滑算法上的时候就会有稍许不同：有的软件使用Catmull-Clark光滑算法。而其它的一些软件却使用自己的完全不同的算法。除非有一天这些三维软件都统一标准使用相同的算法（比如Pixar创造的OpenSubdiv算法，你可以给使用的三维软件公司写邮件，鼓励他们实现这个目标。国内的童鞋写信之前最好先确认一下自己有没有卖正版先），否则的话你置换出来的结果就会和你的在雕刻软件里面雕刻的东东不一样。不过好消息就是：只要你渲染置换贴图的低模不要低的太离谱，这些差别也不会太明显。总的来说，不要期望置换贴图是成为你的灵丹妙药。如果你试图着想要把一个简单的多边形cube置换出一个苹果来，那么就不要为看到结果感到蛋痛。好的办法是：让你的低模有基本的大型以及足够的精度，让置换贴图来渲染出细节。
 
置换贴图创建及使用步骤
So now we know how floating-point displacement maps work and what to expect from them. It's just a matter of pushing the right buttons to correctly generate and apply them in our 3D packages. Below I've laid out step-by-step procedures of how to generate floating-point displacement maps from the major sculpting package of your choice - and apply them in the renderer of your choice.
现在，我们知道了浮点类置换贴图是什么东西了，以及用它来干嘛。接着要做的无非就是按下准确的按钮获得置换贴图，然后在三维软件中去使用。下面，我将以主流雕刻软件来讲解如果一步一步的创建出浮点类置换贴图接着在主流的渲染器中使用它。

Each of the settings in the following workflows are the result of careful testing. If you're curious about any of the settings, just click the "(?)" next to a step to view a popup explaining what the setting does and why it's set as it is. The version number of each program is the version the procedure was tested with.
下面所用的每一个参数设置都经过了仔细的测试，各位可以放心大胆使用，如果你想搞清楚为什么要这么设置，点击后面的?就可以出现详细的解释。另外，列表里面的软件版本就是测试这些参数所使用的版本。

zbrush 4 r5版本

01.Open or Import your high-res mesh with multiple subdivision levels.
01.打开或者导入带有细分级别的模型
02.If you imported your high res mesh from another program - rebuild the lower subdivisions by going to the Tool palette, expanding the Geometry subpalette, and clicking the 'Reconstruct Subdiv' button until at the lowest desired level.
02.如果你的高模是从其他软件导入过来的而不带细分级别的话，可以通过重建细分级别获得，方法是：tool—Geometry—Reconstruct Subdiv。

03.In the Tool palette, expand the Geometry subpalette, and set your current 'SDiv' value to the level you want your low resolution mesh to be at.
03.在tool—Geometry面板里面，调节到你需要的细分级别。
04.In the Tool palette, expand the UV Map subpalette, and set the UV Map Size to the image resolution that best suits your needs. (Recommended 2048 or higher)
04.在tool—UV Map面板里面，设置需要的UV Map的大小（推荐2048或者更高）
05.In the Tool palette, expand the Displacement subpalette, and click the large empty box in the upper right and select any alpha image from the popup menu.
05.在tool—Displacement面板里面，点开右上角那个最大的空盒子选择任何alpha图片。
06.Now that an image is loaded into the box, the 'Mid' value below and to the right should no longer be greyed out, so set it to a value of '0'.
06.此时图片就被载入了，旁边的'Mid' 参数将不再是灰色，设置这个值为“0”
07.Click the same large box with the alpha image in it now, and select 'Alpha Off' from the upper left to clear the box once again.
07.选择刚才载入alpha的框，选择'Alpha Off'。清除选择。
08.Set 'Adaptive' to OFF. (?)
08.Set 'Adaptive' to OFF. (why？Setting this to ON is supposed to produce a higher-quality displacement map.
But through experimentation I have found it to be generally unreliable and unnecessary at larger resolutions.
At times it can even result in a displacement map that is completely useless - So I recommend leaving it OFF.)
08.'Adaptive'设置成OFF，即关闭（为什么这么设置：开启Adaptive这个参数本来是可以创建出更高精度的置换贴图的，但是经过本人多次试验发现开启这个参数创建出来的置换贴图并不好，有时甚至可能造成生成的置换贴图完全不可以用-所以我剪辑关闭这个参数）
09.Set 'DPSubPix' to '4'. (why？This setting determines the accuracy of the displacement map created for the object.
Higher values cause a higher-quality displacement map to be generated, but will take longer to generate.
If your high resolution mesh is very high poly (16mil or larger), or your displacement map size low (2048 or lower), then you can get away with setting this to a lower value like 2.)
09.'DPSubPix'设置成4（为什么这么设置：这个参数控制置换贴图创建的准确度，参数越大质量越好，但是会花更多的时间，如果你的模型精度非常高（比如1.6亿甚至更多的面数），或者你的需要算的置换贴图很小（2048或者更小），这时你可以把这个参数设置的小一点，比如2）
10.Set 'SmoothUV' to OFF. (why？Setting this to OFF disables UV Smoothing on our low res mesh.
We'll match this setting in our renderer to ensure an accurate mapping of displacement details.)
10.'SmoothUV'设置成OFF，即关闭（为什么这么设置：把这个参数设置成OFF即关闭低模的UV Smoothing，在后面的渲染中也需要在渲染器里面设置相关参数和次参数匹配以获得准确的置换细节）
11.Set 'Flip V' to ON. (why？Setting this to ON compensates for the way ZBrush deals with UV maps internally.)
11.开启'Flip V'（为什么这么设置：开启这个参数是为了抵消zb内部的uv翻转）
12.Set 'Scale' to '1'. (why？This setting determines the scale of the generated displacement map's pixel values.
Since we want an exact 1:1 match, we'll leave this at a default value of 1.)
12.'Scale'设置为1（为什么这么设置：这个参数决定生成的置换贴图的像素值，因为我们需要1比1的匹配，所以设置这个值为1）
13.Set '3 Channels' to OFF. (why？Setting this to OFF stores our displacement information using only the RED channel of our generated displacement map.32bit Displacement only needs one channel to store it's info, so this setting will slightly lower filesizes without losing any info.)
13.'3 Channels'设置成OFF，即关闭（为什么这么设置：关闭这个参数就会把生成的置换贴图值保存在红色通道，32位的置换贴图只需要一个通道来储存，所以这样设置可以减少文件尺寸并且不会有任何信息的丢失）
14.Set '32Bit' to ON. (why？Setting this to ON enables the export of a 32bit floating-point displacement map.)
14.开启'32Bit'（为什么这么设置：开启后才能生成32位的浮点置换贴图）
15.Here is a screengrab of the above settings to verify.
15.以上的设置如下图所示
置换贴图精华帖

16.Click the 'Create And Export Map' button, choose a filename and directory to save your map to, and select 'OpenEXR 32bit' as the file type.
16.点击 'Create And Export Map'按钮，输入文件名和保存路径，并且在文件类型中选择 'OpenEXR 32bit'
17.Click the 'Save' button to run the displacement map generation.
17.点击'Save'按钮保存你的置换贴图
18.Your displacement map is now ready for use!
18.现在你的置换贴图已经创建好并且可以使用了！
