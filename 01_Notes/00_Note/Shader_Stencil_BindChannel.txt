Shader笔记：

Stencil:模板
	模板缓冲器可以用作每个像素掩模的通用目的，用于保存或丢弃像素
	模板缓冲器通常是每像素8位整数。 该值可以写入，递增或递减。 后续的绘制调用可以测试该值，以决定是否应该在运行像素着色器之前丢弃一个像素。

语法：

Ref：要进行比较的值，如果Comp的值不是Always,和要写入缓冲区的值，，如果是Pass，Fail或者是ZFail 则设置为替换
0-255的整数

ReadMask:
8位掩码作为0-255整数，在将参考值与缓冲区（referenceValue＆readMask）comparisonFunction（stencilBufferValue＆readMask）的内容进行比较时使用。 默认值：255。

WriteMask:
8位掩码作为0-255整数，写入缓冲区时使用。 默认值：255。

Comp:
用于将参考值与缓冲区的当前内容进行比较的函数。 默认值：always。

Pass:
如果模板测试（和深度测试）通过，如何处理缓冲区的内容。 默认值：保持。

Fail:
如果模板测试失败，该如何处理缓冲区的内容。默认值：保持。

ZFail:
如果模板测试通过，则缓冲区的内容如何处理，但深度测试失败。 默认值：保持。

Comp，Pass，Fail和ZFail将应用于前向几何，除非指定Cull Front，在这种情况下它是后向几何。 您还可以通过定义CompFront，PassFront，FailFront，ZFailFront（用于前置几何体）和CompBack，PassBack，FailBack，ZFailBack（用于背面几何体）显式指定双面模板状态。

Comparison Function

Greater:仅渲染参考值大于缓冲区中的值的像素。
GEqual:
Less:
LEqual:
Equal:
NotEqual:
Always:使模板测试始终通过。
Never:使模板测试始终不通过。

Stencil Operation

Keep:保持缓冲区的当前内容。
Zero:将0写入缓冲区。
Replace:将参考值写入缓冲区。
IncrSat:递增缓冲区中的当前值。 如果值已经是255，它保持在255。
DecrSat:递减缓冲区中的当前值。 如果值为0，则保持为0。
Invert:取消所有位。
IncrWrap:递增缓冲区中的当前值。如果值已经是255，它将变为0。
DecrWrap:递减缓冲区中的当前值。如果值为0，则为255。

在延迟渲染路径中渲染的对象的模板功能有些受限，因为在基本传递和光照传递期间，模板缓冲区用于其他目的。在这两个阶段期间，在着色器中定义的模板状态将被忽略，并且仅在最后一遍中被考虑。因为它不可能基于模板测试来掩蔽这些对象，但它们仍然可以修改缓冲区内容，以供稍后在框架中呈现的对象使用。在延迟路径之后的正向渲染路径中渲染的对象（例如透明对象或没有表面着色器的对象）将再次正常设置它们的模板状态。

延迟渲染路径使用模板缓冲区的三个最高位，加上最多四个最高位 - 这取决于场景中使用了多少光掩模层。可以使用模板读写掩码在“干净”位的范围内操作，也可以在使用Camera.clearStencilAfterLightingPass进行光照通过后强制相机清洁模板缓冲区。

UI 的Mask遮罩就是用stencil来实现的，所以我们如果用stencil做UI的特效或者物体遮罩，每次需要创建新的Mask的时候，需要将stencil清空一次，做法就是创建一个Image，然后在Image上挂上自己更改的UIShader的材质球，这个UIShader，把ref值设为0就可以了，然后就不会和之前的那些stencil里的值冲突了

新的Ref = NR 旧的Ref = ORef
NC OC
NP OP
if(newComp(newRef,oldRef))newPass;
Mask组件会自动给Ref [_Stencil]赋值

ShaderLab:Legacy BindChannels
BindChannels 命令允许您指定顶点数据如何映射到图形硬件。

注意：当使用Vertex programs的时候，BindChannels没有效果，因为绑定由顶点着色器输入控制。
建议现在使用可编程着色器，而不是用 fixed function vertex processing

默认情况下，Unity会找出你的bindings，但在某些情况下，你会想要自定义bindings

例如，你可以映射要在第一个纹理阶段使用的主要UV集和第二个纹理阶段使用的辅助UV集；或者告诉硬件顶点颜色应该考虑

语法：
BindChannels { Bind "source", target }
指定顶点数据映射到硬件目标上

Source can be one of:

Vertex：vertex position             // 顶点位置
Normal：vertex Normal               //顶点法线
Tangent：vertex Tangent             //切线
Texcoord：primary UV coordinate     //UV1
Texcoord1：secondary UV coordinate  //UV2
Color：per-vertex Color             //每个顶点的颜色

Target can be one of:

Vertex：vertex position              //顶点位置
Normal:：vertex normal               //顶点法线
Tangent:：vertex tangent             //顶点切线
Texcoord0, Texcoord1, …：texture coordinates for corresponding texture stage          //相应纹理阶段的纹理坐标
Texcoord：texture coordinates for all texture stages                               //所有纹理阶段的纹理坐标
Color：vertex Color                  //顶点颜色

Details
Unity对哪些源映射到哪些目标有一些限制。
源和目标碧玺匹配 Vertex、Normal、Tangent、
Color
来自网格（Texcoord和Texcoord1）的纹理坐标可以映射到纹理坐标目标（所有纹理阶段的Texcoord，或特定阶段的TexcoordN）

下面有两个使用BindChannels的经典案例
//映射第一个UV到第一张贴图
//第二个UV到第二张贴图
BindChannels {
   Bind "Vertex", vertex
   Bind "texcoord", texcoord0
   Bind "texcoord1", texcoord1
}

// Maps the first UV set to all texture stages
// and uses vertex colors
// 映射第一个UV到所有的贴图
// 使用顶点颜色
BindChannels {
   Bind "Vertex", vertex
   Bind "texcoord", texcoord
   Bind "Color", color
}


https://www.opengl.org/registry/specs/NV/fragment_program4.txt

"+ Precision Hints (ARB_precision_hint_fastest, ARB_precision_hint_nicest)
"精确提示(ARB_precision_hint_fastest, ARB_precision_hint_nicest)"

Fragment program computations are carried out at an implementation-
dependent precision. However, some implementations may be able to perform
fragment program computations at more than one precision, and may be able
to trade off computation precision for performance.
"片段程序在执行计算的时候的相关精度。然而，一些实现可能能够执行片段程序计算在一个以上的精度，并且可能会牺牲一些计算性能"


If a fragment program specifies the "ARB_precision_hint_fastest" program
option, implementations should select precision to minimize program
execution time, with possibly reduced precision. If a fragment program
specifies the "ARB_precision_hint_nicest" program option, implementations
should maximize the precision, with possibly increased execution time.
"如果fragment指定'ARB_precision_hint_fastest'的程序选项，实现应选择精度以最小化程序执行时间，可能降低精度"
"如果片段程序指定'ARB_precision_hint_nicest'的程序选项，实现应最大化精度，可能增加执行时间"

Only one precision control option may be specified by any given fragment
program. A fragment program that specifies both the
"ARB_precision_hint_fastest" and "ARB_precision_hint_nicest" program
options will fail to load."
"只有一个精度控制选项可以由任何给定的片段指定程序。一个片段程序，如果同时指定'ARB_precision_hint_fastest'和'ARB_precision_hint_nicest'程序选项将无法加载"


片段程序计算在执行 -
相关精度。
然而，一些实现可能能够执行
片段程序计算在一个以上的精度，并可能能够
以牺牲性能的计算精度。
如果片段程序指定“ARB_precision_hint_fastest”程序
选项，实现应选择精度以最小化程序
执行时间，可能降低精度。
如果是片段程序
指定“ARB_precision_hint_nicest”程序选项，实现
应该最大化精度，可能增加执行时间。
只有一个精度控制选项可以由任何给定的片段指定
程序。
一个片段程序，指定
“ARB_precision_hint_fastest”和“ARB_precision_hint_nicest”程序
选项将无法加载。


ShaderLab: Legacy Texture Combiners
传统的纹理合成
