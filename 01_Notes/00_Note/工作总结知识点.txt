线性空间和伽马空间是两种不同的渲染，前者效果更好，但也更消耗性能。
matcap是把法线转换到摄像机空间，以发现的R和G作为UV，对matcapTexture进行采样
有的参数不能使用0或者1，0.017-0.063

ShaderForge插件会把Unity Shader的变种的下拉框给覆盖掉，慎用

星光效果算法：

LightWrapping算法：

头发渲染的算法：


SHADER_TARGET 被定义为与着色器目标编译模型匹配的数值
着色器被编译成Shader Model3.0时为30；
#if SHADER_TARGET < 30
    // less than Shader model 3.0:
    // very limited Shader capabilities, do some approximation
#else
    // decent capabilities, do a better thing
#endif

UnityCG.cginc中的ShadeSH9(float4 normal);函数可以直接取到场景中灯光探针的信息


让一个颜色明暗对比变大，可以采用对颜色值进行Pow运算，也可以对颜色值进行Remap 0-1到0-1的运算（调整色阶），只调整Remap的输入的最小值变大


同一个物体的渲染队列是由三角面的创建顺序决定的
PS 里的PNG是直接把所有的透明的删掉，创建Alpha通道没用

做类似绳子的物体的时候，可以采用逆向工程，先做一条竖直的，分好UV，做好高模，烘培贴图，然后再做弯曲的绳子，只要把绳子的UV变成竖直的和之前那个匹配起来就可以了。


游戏的风格一定要从原画开始就要考虑，原画出了问题，后面就很难改，很难出效果

half4 frag(v2f i ,float facing:VFACE):SV_Target  //facing可用来判断正反面

不同的材质球属性就会导致不同DC

12、MaxScript的逻辑运算符是and or
13、MaxScript 可以加载.Net的东西，用dotNet.loadAssembly
14、粒子系统的Shader颜色必须调成128，否则会有问题

两个物体离得很近的时候，光线就会在这两个物体之间反射，反射不出去，这部分就会变得比较黑

v2f结构体里面的位置都要写成pos，因为有的Unity自带的函数用了这个变量。

UsePass "Legacy Shaders/VertexLit/SHADOWCASTER"

注意骨骼旋转模式TCB和欧拉的不同

float3x3 Test : TEXCOORD1 放在v2f中，Unity会自动转化成float3 Test[0] : TEXCOORD1  float3 Test[1] : TEXCOORD2 float3 Test[2] : TEXCOORD3

法线贴图里存的是高模模型空间法线信息转换到切空间的法线信息，由于高模面熟很多，每个面之间都非常平滑，所以Z方向上的偏移最小，影响最小，可以把它舍弃掉存放别的信息。

成组功能要先创建物体，改变他的Parent再改变他的Transform的position和rotation

Unity Shader里Name后面的所有字母必须大写

平行光投射阴影有2种方式：
Close Fit渲染较高分辨率的阴影，但是如果相机移动时，有时阴影会轻微摆动。Stable Fit渲染的阴影分辨率较低，不过相机移动时不会发生摆动。

缩放Unity地形时，要缩放它的长度宽度和高度

Unity Light 的  cull mask对烘焙没有效果，在5.6.2，官方人员说是一个Bug，由于要重构很多模块，所以暂时不能修复

CGINCLUDE ENDCG里的内容会被所有的Pass引用

ShadowCaster不论写在哪个SubShader中，Unity 都会调用，并且不受LOD的影响

只要场景中有一个物体投射阴影，那么接受阴影的物体的面数就会翻倍，要接受阴影面数就会翻倍

如果将向量先转化到模型空间，然后再从模型空间转化到切线空间，会出现在不同的角度lightDir不同的情况

tex2Dlod在低版本的手机上支持得并不是很好，因为Shader而出现的问题首先应该屏蔽这个函数的使用

Category 会把它下面的所有Fog、Tags或Blend 应用于所有的SubShader

Unity的快捷键不能设置为单个字母“h”，不然会出现打字无法打出这个字母

LightMode 不能写在 SubShader 下面，否则会出现ShaderCaster的Pass不起作用

LightMap OFF 必须写在LightMap ON 之前，否则会出现不能识别的问题

Light Parameters里的 push off 可以控制影响自阴影产生黑点

appdata里的COLOR语义必须要大写，不大写在安卓手机上会出错

pc平台对语义关键字的大小写没要求，但是移动平台要求必须明确大小写

Queue必须是 “Geometry”“AlphaTest”才能接受投影

Transparent 和 TransparentCutout烘焙后都不受ndotl影响

Terrain的混合贴图不能压缩，否则会有可能出现一些小黑点，是像素被压缩导致的

使用Lerp处理法线强度，一定要使用normalize，虽然效果看起来几乎一样，但是，经过Blinn-Phong的Pow运算之后就会变得很不一样

Shader 做LOD，分不同的等级，分成多个文件可以决定每个不同物件的开始级别，如果不是出于这个目的，就把Shader的LOD写在同一个文件中做成SubShader

位置信息POSITION 的 精度不能随便更改，要根据场景中最大的距离来定

动态加载烘焙场景可能出现，LightMap_On 关键字失效问题：打包的时候要在一个烘焙过的场景打包；或者使用自定义的LightMap 关键字

com.qti.permission.PROFILER

Unity的float3x3，float4x4这些矩阵，可以通过matrix[0]、matrix[1]这样取值，但是不能通过matrix[0]这种方式赋值，这种赋值在一些型号的手机上会导致赋值不成功,通过float3x3()这种方式赋值

雪雨法线向上的遮罩：mask = saturate( _Sharpness * ( Height - worldNormal.y + _Offset)); 

Glitter 星光：
fixed3 GlitterSimple(float2 uv,float3 wN,float3 wV,float3 wL)
{
fixed4 sparkle = tex2D(_SparkleMap,TRANSFORM_TEX(uv,_SparkleMap));
half3 glitter = frac(0.6 * wN + 9 * sparkle + wV * wL);
glitter = saturate(1 - 2.5 * (glitter.x + glitter.y + glitter.z)) * 1.25 * _GlitterIntensity;
return glitter;
}

Round(x) 将x舍入为最接近的整数

如果RenderTexture中要使用stencil buffer 需要RenderTexture的Depth是24位，16位会使stencil 出现错误。

Fragment Shader 最后输出的RGBA值，最好保证在0 -1，Unity有时候的混合模式会读取到大于1或者小于0的值，从而导致混合出问题

Unity Baked Indirect 在过大的世界位置上有问题

一定要给美术讲清楚 meta 文件的作用，ID的含义

Unity自动展开灯光贴图UV可能会出现问题，需要自己手动在Max里展开UV

简单的模拟水折射实现：
o.screen = ComputeScreenPos(o.pos)
fixed4 reflectTex = tex2D(_ReflectTex,(i.screen.xy/i.scren.w) + normalDir.xy * 0.3);
finCol += reflectTex * 0.5;

Max 导出摄像机动画的时候，只导出虚拟体就可以了，不要把虚拟体和摄像机物体一起导出

Unity 中的FBX模型，勾上Import Animation，即使没有动画也会占比较大空间。

尽量少得让人工输入和配置，因为人总会出错，配置和输入的东西越多，出错的几率就越大。

Alpha Blend 的Shader最后要进行Saturate ,否则会出现混合错误的情况

SVN 使用注意大小写

处理贴图的WrapMode时，要注意有没有UV在0-1外面的模型，一定要注意到

烘焙好后的贴图，有小问题可以通过PS修正

OUT.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  
OUT.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  
OUT.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  
float3 worldNormal = normalize(half3(dot(IN.TtoW0.xyz, bump), dot(IN.TtoW1.xyz, bump), dot(IN.TtoW2.xyz, bump)));
尽量避免在片段程序中使用矩阵乘法，在一些手机的GPU上会不支持，如果非要使用就用上面的点积的方法代替矩阵乘法。

Unity动画文件更新直接覆盖会出现问题，要先删除再替换，因为删除会替换meta文件，而覆盖会更新meta，有时候更新就会出问题。

如果最终使用RT显示物体，一定要注意不透明物体的Alpha输出，即使你在渲染的摄像机上看是正常的，但是如果RT用AlphaBlend，那就有可能出问题。

用于烘焙的场景模型，最好使用旋转来对称复制，这样可以保证Turn线是正确的。烘焙出现明显的接缝是2号UV的问题，可以通过合并UV顶点和处理Turn线来解决。如果还不行，那就手动展2UV。

使用skip_variants 不能剔除关于Fog任何一个的变种，剔除任何一个就会导致fog不起作用，5.6.5测试的问题

导出Skin文件，包含模型骨骼虚拟体，不包含动画；导出动作文件，包含骨骼虚拟体，不包含模型

rcp(x) 返回 1/x，这种方法计算倒数更加高效快速近似，不过这个函数只在SM5.0上支持
 
ColorMask 14是屏蔽 A通道输出，15是RGBA

Shader重映射算法，将Val从iMin-iMax映射到:
inline float Remap(float Val,float iMin,float iMax,float oMin,float oMax){
    return oMin +  (Val-iMin)*(oMax-oMin) /  (iMax-iMin+ 1e-5f) ;
}

通用溶解实现
dissolveAmount 是输入的值[0-1];reference 是参考的贴图值;
width 是溶解边缘宽度 1;hardness 是溶解边缘硬度 1.5;
dissolveEdge 是最终输出用于插值颜色的值。
```
realDissolveAmount = Remap(1-dissolveAmount,0,1,-0.1,1.1);
clip(realDissolveAmount - reference);
dissolveEdge = 1 - saturate(Remap(realDissolveAmount - reference,0,width*0.1,-hardness,hardness));

如果在顶点程序中归一化，然后从顶点程序传到片段程序中，可能出现数据丢失，要保证精度就统一在片段程序中归一化，不过这两者只有在特写镜头才能很明显地看出区别

Unity 使用延迟渲染之后，即使场景中只有一个主灯光也会对物体的渲染有影响

T4M 会在场景中创建隐藏的物体来覆盖原本物体的显示，使用T4MPreview，有可能导致显示不正确，一般都不会出现这个问题，不排除美术的迷之操作。2018/07/17/02:26

如果没有切线，切线会自动附默认值为float4(1,0,0,0)， 一定注意w分量是0，在使用时要注意

在计算副法线的时候不要进行normalize，binormal = cross(tangent,normal) * tangent.w; 如果改成 binormal = normalize(cross(tangent,normal) * tangent.w)。编译完Shader代码后，会出现 rsq ** **，或 nrm ** ** ，如果此时没有tangent，tangent.w 会是0，这样rsq和nrm 会出现 非零值，返回结果为 FL_MAX，最终导致渲染结果出错。

Unity 贴图的offset的数值是以一张贴图为单位的，如果平铺多次，offset为1的时候就只平移一张图片的位置，而不是整个UV大小

---------------

不同平台开发方向不同：PC：榨干显卡所有性能；手机：合理机能下最优的画面

DirectX 是左乘，行向量，在A空间下定义的B空间基向量，构造的矩阵，左乘一个行向量（行向量在左，矩阵在右，矩阵每一行表示一个基向量）mul(float1x4,float4x4)，表示将这个向量从B空间转换到A空间，如果行向量在右，矩阵在左，用mul函数会自动转置矩阵并放在右边mul(float4x4,float1x4) = mul(float1x4,float4x4_T)，表示将这个向量从A空间转换到B空间

02083963555
13686985677