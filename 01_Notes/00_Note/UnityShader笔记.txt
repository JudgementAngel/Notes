图形处理器（GPU）简史
	GPU发展简史
	可编程GPU
	GPU的优点和缺陷
Vertex Shader
	所谓Vertex，就是我们熟悉的组成3D图形的顶点，由于设计3D模型是基于坐标空间内部设计的，所以Vertex信息包含了3D模型在空间内的坐标信息。VertexShader则是对于Vertex信息的运算编程器，可以通过赋予特定的算法而在工作中改变3D模型的外形，VertexShader顶点运算单元可以直接检索显存中的材质数据。现在的游戏场景越来越复杂了。所涉及到的材质和多边形数量都非常惊人。顶点材质技术可以极大的提高GPU在处理复杂的游戏场景时的效率。并且游戏开发人员还可以利用VertexShader的这一新的特性，充分发挥想象，实现很多非常漂亮的特效

GPU的优越性
	由于GPU具有高并行结构，所以GPU在处理图形数据和复杂算法方面拥有比CPU更高的效率。CPU大部分面积为控制器和寄存器，与之相比，GPU拥有更多的ALU(Arithmetic Logic Unit，逻辑运算单元)用于数据处理，这样的结构适合对密集型数据进行并行处理。
	GPU采用流式并行计算模式，可对每个数据进行独立的并行计算，即，流内任意元素的计算不依赖与其它同类型数据，例如，计算一个顶点的世界位置坐标，不依赖与其他顶点的位置，所谓“并行计算”是指“多个数据可以同时被使用，多个数据并行计算的时间和1个数据单独执行的时间是一样的”。所以在顶点处理程序中，可以同时处理N个顶点数据。




Shader和图形渲染管线
    Shader，中文翻译即着色器，是一种较为短小的程序片段，用于告诉图形硬件如何计算和输出图像，过去由汇编语言来编写，现在也可以使用高级语言来编写。一句话概括：Shader是可编程图形管线的算法片段，它主要分为两类，VertexShader和FragmentShader

    渲染管线也称渲染流水线，是显示芯片内部处理图形信号相互独立的并行和按照固定顺序进行的阶段。每个阶段都从它的前一阶段接收输入，然后把输出发给随后的阶段。就像一个在同一时间内，不同阶段不同的汽车一起制造的装配线，传统的图形硬件流水线以流水的方式处理大量的顶点、几何图元和片段

	Shader是图形可编程方案的程序片段
	渲染管线是一种计算机从数据到最终图像成像的形象描述
	材质是商品，Shader是方法，贴图是材料


如果把矩阵的行解释为坐标系的基向量，那么乘以该矩阵就相当于执行了一次坐标变换，若有aM = b，我们就可以说，M将a转换到b。从这一点看，术语“转换”和“乘法”是等价的。


Unity Shader 的形态
Shaderlab 基本结构

shader "name"
{
    [Properties]//属性
    SubShaders	
    [FallBack]//当上面的SubShader都不能执行的时候，跳转到这个
}

Build-In Shader


profile
一个CG profile定义了一个“被特定图形硬件或API所支持的CG语言子集”，任意一种Shader language都是基于可编程图形硬件的（寄存器、指令集等），这也就意味着：不同的图形硬件对应着不同的功能子集。这些可选的语言功能包括某些控制结构和标准库函数。profile还定义了数据类型的精度，并且制定数据类型是否全部或仅部分支持。profile按照功能可以划分为顶点profile和片段profile，而顶点profile和片段profile又基于OpenGL和DirectX的不同版本或扩展，划分为各种版本
http://http.developer.nvidia.com/Cg/fp20.html

http://http.developer.nvidia.com/Cg/Cg_language.html


3D数学基础1 - 坐标系
	
	模型坐标系
	世界坐标系
	摄像机坐标系
	屏幕投影坐标系
变换叫做MVP

左手unity右手max坐标系
                                                                                       
引擎中是直接旋转坐标系，不考虑物体的旋转
物体不旋转的时候，我们使用不旋转的坐标系
对不同的物体给予不同的坐标系参数

小孔呈像

向量点积 Dot 的结果是一个标量值a 如果两个向量都是规范化的，则acos(a)是两个向量的夹角
向量点乘的意义：是一条边向另一条边的投影乘以另一条边的长度。
向量a点乘向量b，夹角为t = |a||b|cos(t)

向量叉积 Cross 的结果还是一个向量 这个向量是垂直于两个向量 法向量
二个向量的叉乘，向量必须是空间向量
设向量AB=向量a-向量b, 向量CD＝向量a+向量b
向量AB＝（x1,y1,z1）, 向量CD＝（x2,y2,z2）
向量AB×向量CD＝（y1z2-z1y2，x2z1-x1z2，x1y2-y1x2）
产生一个新向量，其方向垂直于由向量AB，向量CD确定的平面，其方向由右手定则确定。

点乘具体如：做功，力与方向的乘积。等
叉乘的结果还是一个向量，垂直原来两个所在的平面，方向也有原来两个向量决定。



矩阵：
	矩阵的维度和记法
	矩阵的转置
	矩阵和标量的乘法
	矩阵和矩阵的乘法 是有顺序的要求，如果交换顺序，结果就会不一样

矩阵是从1开始，数组是从0开始

行向量、列向量是按照矩阵的列法
单位矩阵去乘一个向量，不会改变这个向量，单位矩阵是主对角线都是1的矩阵

Form窗口，x向右是正，y向下是正，默认的原点是在左上角


2D旋转矩阵，绕坐标中心旋转a角度 一般使用的是弧度制

Cos(a) 	Sin(a)
-Sin(a)	Cos(a)

沿坐标轴缩放

Kx	0
0	Ky

沿任意N轴缩放

1+(K-1)Nx*Nx	(K-1)Nx*Ny
(K-1)Nx*Ny	1+(K-1)Ny*Ny

3D旋转矩阵

X:
1	0	0
0	Cos(a)	Sin(a)
0	-Sin(a)	Cos(a)

Y:
Cos(a)	0	Sin(a)
0	1	0
-Sin(a)	0	Cos(a)

Z:
Cos(a)	Sin(a)	0
-Sin(a)	Cos(a)	0
0	0	1


变换种类：

	旋转	缩放	平移	镜像	切变
	投影（平行投影）	投影（透视投影）
	可逆	等角	正交	刚体
	
	线性变换	仿射变换
	所有的线性变换都是仿射变换，但是反之并不成立



变换的组合
2D平移需要用3x3的矩阵，向量也需要变成三维的，在后面加 1 



-2016.08.22

方阵
	行和列相等
行列式
二阶：
	|M| = |m11 m12| = m11m22-m12m21
              |m21 m22|
主对角线是正，反对角线是负值

P110
代数余子式
	余子式还是一个矩阵，不过比原来的维度少1

行列式为零的矩阵叫奇异矩阵，该矩阵没有逆

矩阵和矩阵的逆相乘的值是单位矩阵

代数余子式矩阵的转置是标准伴随矩阵

矩阵的逆矩阵=标准伴随矩阵/原矩阵的行列式的值

两个矩阵是互为逆矩阵

一个矩阵乘以它的转置等于单位矩阵，该矩阵叫正交矩阵


光照必须取反向，从顶点指向光源
用向量的点积求光照强度
UV左手方向的叉积为法向量
v1(1,0,1) v2(2,0,3)
cross(v1,v2)得到的是反向的法向量


光照和法线必须在同一个空间中，否则不能正确计算
点积可以帮助我们判断正反面
视向量是从顶点指向摄像机的向量

Ambient+Diffuse
Bulit-in shader variables
顶点光照和片段光照

实现漫反射_课时总结
1、对顶点进行合适的mvp变换
2、在统一的坐标空间里计算法向量与光向量的点积
3、顶点程序计算光照执行效率高，片段程序计算光照较慢但更细腻平滑

reflect函数
L:入射(顶点指向光源) R:反射 N:法线

L+R = 2*Cos(N,L)*N = 2*Dot(N,L)*N
R = 2*Dot(N,L)*N - L;


Ambient Color + Diffuse Color + Specular Color 就是常说的phong光照模型

颜色缓冲区，存放depth信息
ZTest的缓冲区的值  小于等于（默认的模式） depth才会输出颜色
ZWrite：是否写入depth缓冲区，进行更新

把一个法线向量可能存在正负，把它压缩到0-1之间，我们通过采样这样一张法线的纹理数据，再把0-1的颜色转换为-1 - +1范围的向量，通过这个向量与光进行计算，就可以得到凹凸，非常丰富的细节，在片段级完成

原始的纹理，把它的灰度值取出来，看它左边和右边相邻的灰度值的差，可以构成一个高度的差值，左右偏移的高度差，上下两个灰度值的差值可以看作是上下偏移的高度差，横向和纵向两个差值可以构成一个差分向量，利用差分向量的向量积可以形成一个法线，保证指向屏幕外面，将法线记录到贴图中，形成法线贴图

根据目标平台的不同，压缩格式是不同的
uv方向是切线空间，基于面的纹理空间 tanget 也叫切线空间

顶点 切线t和法向量n垂直,t和n的叉积得到的向量b,这个三个向量形成的空间，叫定点坐标系

次表面散射
透明物体的折射
菲尼耳定律
对光进行折射
体积光体积物
BRDF,光照模型
后期效果
GPGPU

Unity内建地形系统

1、地形参数设置
2、地形纹理
3、地形材质
4、第一个定制shader
DX11

当导入四个以上的贴图的时候，地形文件下面会生成两张贴图
当超过我们能够表达的范围时，我们就需要创建一个新的贴图，取到一个权重

脚本参数设置
addpass
Unity的内建Shader

Unity的地形系统会自动给其材质球的Shader的指定名称的贴图全局地设置贴图
Shader.SetGlobalTexture

一个片段程序中的采样次数是受到硬件的限制的，所以我们不能无限的在一个片段程序中多次采样，就需要用到多个Pass通道

Unity能为我们全局设置的贴图只有:_Control,_Splat0,_Splat1,_Splat2,_Splat3
CGINCLUDE
ENDCG
中间的内容是插在CGPROGRAM-ENDCG之间的

5.x surface shader的注意事项
定制地形 surface shader
传统光照对比GI

5.0之后 Surface Shader 贴图的数量有限制
把tc_Control和fogCoord合并在一个四维向量中

增加一个新的 add pass shader 
Decal：add混合模式
Finalcolor 函数与alpha值的设定

在surface中调整漫反射的颜色
黑边处理方法1：直接设置Alpha为0，然后再FinalColor中把*Alpha去掉
我使用的是自带的Shader中的方法
FinalColor的颜色是针对光照过后的颜色所进行的处理
"DisableBatching"="True"关闭批处理
exclude_path:deferred不要为延迟渲染路径生成代码

投影纹理映射
图形流水线
Shader中的具体应用

投影纹理采样 没有使用模型的纹理坐标
normalMatrix 
	0.5	0	0	0.5
	0  	0.5	0	0.5
	0	0	0.5	0.5
	0	0	0	1
texViewProjMatrix = normalMatrix * projectionMatrix * viewMatrix *worldMatrix
ComputeScreenPos
透视除法建议放在片段程序中运算

projector
阴影投影
Shader实现
投影纹理矩阵

GL.GetGPUProjectionMatrix可以按照不同的平台

投影纹理映射 - 阴影映射原理

ReplacementShader
深度图渲染
设置投影纹理矩阵
深度图采样与对比

光的折射原理 - snell定律
抓取通道及采样
波动公式
创建网格
利用偏导数计算法线

斯涅尔定律 - 百度百科

水面的完整模型(百度)

偏导数：在数学中，一个多变量的函数的偏导数，就是它关于其中一个变量的导数而保持其他变量恒定（相对于全导数，在其中所有变量都允许变化）。偏导数在向量分析和微分几何中是很有用的

不能用ddx函数
ffd
菲利普斯
傅里叶变换

光的折射与Shader实现原理 - 火
Blend运算的局限
模拟空气热膨胀后的光折射
Grabpass的再应用

火焰的渲染顺序是在物体之后的，渲染队列应该改为Transparent
做火焰扭曲的衰减可以使用采样图片PNG的Alpha值和R分量作为依据
火焰shader的采样不会涉及之前有的粒子的渲染的图像，所以可以采用的解决办法是，在粒子上面再加一个Pass通道专门用于对原有的纹理进行扭曲

变换法向量到视空间
Snell定律的简单模拟
更廉价的方案
扩展：法线贴图

光的反射之Shader实现原理
菲涅耳（Fresnel）效果近似
Shader中的实现

折射率：
真空\空气：1.0\1.0003
水：1.333
玻璃：1.5 - 1.7
钻石：2.417
冰：1.309

可以根据眼空间（摄像机空间）的向右的向量的夹角大小来判断Uv偏转的方向
_ScreenParams的四维向量xy代表了屏幕宽高

水面的fresnel
纹理法线的应用
折射的动态形成
反射和折射的混合
水面高光的形成

Fresnel的近似：
fresnel = fresnel偏移量 + fresnel缩放量*pow(1 + dot(N,V),5)
这个V是眼睛指向顶点方向

反射和折射的混合
finalColor = lerp(reflectColor,refractColor,fresnel)
菲涅耳混合的方式和直接计算边缘光是有区别的

通过深度图来获得水和陆地的交界线

色散
折射色散
Cube纹理采样模拟色散
Fresnel与色散

红绿蓝三个通道进行偏转
折射率

对色散进行模拟，最关键的是每次采样的偏转率要根据物理的原理，红偏转最大，蓝偏转最小


镜面成像
实像和虚像的关系
平面
基于平面的裁切Shader

镜面反射的虚像和实像是与镜面对称的，实像和虚像的顶点连线与镜面垂直，且顶点到镜面的垂直距离相同

镜像变换矩阵的推导

反转剔除
Shader中设置裁剪平面
摄像机的投影倾斜矩阵

雾化的方法是：把物体的转化到摄像机的观察空间，就可以得到物体距离摄像机的远近，用这个值对雾的效果进行处理即可