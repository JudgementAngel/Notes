/*
	不管是vertex shader还是fragment shader，在编译之前都放到这个Context里。可以通过cgCreateProgramFromFile函数创建一个Cg程序，然后将Context和这个程序连接起来。
	*/

	/*
	CGprogram myCgVertexProgram =
	cgCreateProgramFromFile(
		Context,               // Cg runtime context 
		CG_SOURCE,             // shader程序的源代码类型 
		programString,        //  shader源代码文件的名字 
		Profile,               // Profile: OpenGL ARB vertex program 
		main,                  // shader程序入口函数
		args);                 // 附加参数，一般为NULL 
	*/

	/*
	上面程序段中，CG_SOURCE和programString可以指定使用哪一种shader程序源代码，如果使用后缀名为.cg的文件作为shader的源代码文件，那么这两个参数分别设置为CG_SOURCE和shader源程序代码文件名即可。Cg也支持预编译好的目标文件作为shader程序的源文件，这时将这两个参数设置为CG_OBJECT和预编译好的shader程序文件名即可。Profile参数指定使用哪一种版本的profile来编译该shader程序，根据profile版本的不同，shader的能力有很大的差别。具体有哪些版本的profile，以及各个不同版本profile的详细情况，大家可以参考http://developer.nvida.com/CgTutorial。
	*/

	//cgGLLoadProgram(CGprogram Program);  

	/*上面的语句在openGL中加载一个创建好的shader程序。参数Program指定该程序是vertex shade程序还是fragment shader程序。

以上的工作都是为了使用shader而做好了准备，下面就可以直接使用这些shader程序了。表现一个3D场景的时候，可能会使用很多不懂得物体。不同的物体可能有不同的物理属性，所以我们可能希望不同的shader程序可以应用到不同的物体上。Cg提供了这样的函数，函数cgGLBindProgram可以绑定一个shader程序到想要表现的物体上。绑定的时候只需要简单的将要表现的物体的渲染代码放到该函数语句后面即可。绑定后，再调用函数cgGLEnableProfile激活指定的profile来编译shader程序。最后，shader程序使用完毕后，调用cgGLDisableProfile函数关闭当前profile。
*/
	/*

	cgGLBindProgram(Program);
	cgGLEnableProfile(Profile);
	// 渲染某物体
	cgGLDisableProfile(Profile);
	
	*/
