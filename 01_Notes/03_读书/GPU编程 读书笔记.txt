1、绪论
    1.1 Programmable Graphics Processing Unit 发展历程
    1.2 GPU VS CPU
    1.3 国内外研究现状
    1.4 本书的主要内容
2、GPU图形绘制管线
    2.1 几何阶段
        2.1.1 从object space到world space
        2.1.2 从world space到eye space
        2.1.3 从eye space到project and clip space
        {
            多边形裁剪是在CVV(Canonical view volume)中完成的。所以从视点坐标空间到屏幕坐标空间分为三步：
            1、用透视变换矩阵把顶点从视锥体中变换到裁剪空间的CVV中；
            2、在CVV进行图元裁剪；
            3、屏幕映射：将经过前述过程得到的坐标映射到屏幕坐标系上

            把顶点从viewing frustum变换到CVV中，这个过程就是我们常说的“投影”
            主要的投影有两种方法：正交投影（平行投影）和透视投影。

            确定只有当图元完全或者部分的存在于视锥体内部的时候，才需要将其光栅化。

            视点去除，不但可以在GPU中进行，也可以是使用高级语言（C\C++）在CPU上实现。使用高级语言实现时，如果一个场景实体完全不在视锥体中，则该实体的网格数据不必传入GPU，如果一个场景实体部分或完全在视锥体中，则实体网格数据传入GPU中，如果高级语言中已经进行了视点去除，那么可以极大地减去GPU负担。

        }
    2.2 Primitive Assembly && Triangle setup
    {
        Primitive Assembly 图元装配，即将顶点根据primitive(原始的连接关系)，还原出网格结构。网格由顶点和索引组成，在之前的流水线中是对顶点的处理，在这个阶段是根据索引将顶点链接在一起，组成线面单元。之后就是对超出屏幕外的三角形进行裁剪。

        还有根据法向量的朝向来进行裁剪，所有的裁剪剔除计算都是为了减少需要绘制的顶点个数。
        裁剪的主要算法包括：
            视域剔除（View Frustum Culling）、背面剔除（Back-Face Culling）
            遮挡剔除（Occlusing Culling）、视口裁剪
    }
    2.3 光栅化阶段
        2.3.1 Rasterization
        {
            光栅化：决定哪些像素被集合图元覆盖的过程（Rasterization is the process of determining the set of pixels covered by a geomertic primitive）。
            主要存在的两个问题：

            点的屏幕坐标值是浮点数，但像素都是由整数点来表示的，如果确定屏幕坐标值所对应的像素？
                绘制的位置只能接近两指定端点间的实际线段位置，例如，一条线段的位置是（10.48，20.51），转换为像素位置则是（10，21）
            
            在屏幕上需要绘制的有点、线、面，如何根据两个已经确定位置的2个像素点绘制一条线段，如果根据已经确定了位置的 3 个像素点绘制一个三角形面片？
                涉及到具体的画线算法，以及区域图元填充算法。通常的画线算法有 DDA 算法、Bresenham 画线算法；区域图元填充算法有，扫描线多边形填充算法、边界填充算法等
        }
        2.3.2 Pixel Operation
        {
            Pixel Operation 又称为 Raster Operation ，是在更新帧缓存之前，执行最后一系列对每个片段的操作，其目的是:计算出每个像素的颜色值。在这个阶段，被遮挡面通过一个被称为深度测试的过程而消除，这其中包含了很多种计算颜色的方法以及技术。
            Pixel Operation 主要包括：
                1、消除遮挡面
                2、Texture Operation ，纹理操作，也就是根据像素的纹理坐标，查询对应的纹理值
                3、Blending 混色，根据目前已经画好的颜色，与正在计算的颜色的透明度（Alpha），混合为两种颜色，作为新的颜色输出。通常称之为 alpha 混合技术。 当在屏幕上绘制某个物体时，与每个像素都相关联的哟一个 RGB 颜色值和一个 Z 缓冲器深度值，另外一个称为是 alpha 值，可以根据需要生成并存储，用来描述给定像素处的物体透明度。如果 alpha 值为 1.0，则表示物体不透明；如果值为 0，表示该物体是透明的
                4、Filtering 将正在算的颜色经过某种Filtering（滤波或者滤镜）后输出。可以理解为:经过一种数学运算后变成新的颜色值
                该阶段之后，像素的颜色值被写入帧缓存中
        }
    2.4 图形硬件
    {
        z buffer（深度缓冲区）
        stencil buffer（模板缓冲区）
        frame buffer（帧缓冲区）
        color buffer（颜色缓冲区）
    }
        2.4.1 GPU内存架构
        {
            寄存器和内存的区别
                从物理结构而言，寄存器是 cpu 或 gpu 内部的存储单元，即寄存器是嵌入在
                cpu 或者 gpu 中的，而内存则可以独立存在；从功能上而言，寄存器是有限存储
                容量的高速存储部件，用来暂存指令、数据和位址。Shader 编成是基于计算机图
                形硬件的，这其中就包括 GPU 上的寄存器类型，glsl 和 hlsl 的着色虚拟机版本
                就是基于 GPU 的寄存器和指令集而区分的。

        }
        2.4.2 Z Buffer与Z值
        {
            可见物体的 Z 值范围位于【0，1】区间，默认情况下，最接近眼睛的顶点（近裁减面上）其 Z 值为 0.0，离眼睛最远的顶点（远裁减面上）其 Z值为 1.0。
            使用 z buffer 可以用来判断空间点的遮挡关系
            著名的深度缓冲区算法（depth-buffer method，又称 Z 缓冲区算法）就是对投影平面上每个像素所对应的 Z 值进行比较的。
            Z 值并非真正的笛卡儿空间坐标系中的欧几里德距离（Euclidean distance），而是一种“顶点到视点距离”的相对度量。
            所谓相对度量，即这个值保留了与其他同类型值的相对大小关系。
            
            z_buffer_value = (1<<N)*(a*z + b)/z
            a = f/(f-n)
            b = (f*n)/(n-f)
            其中f表示视点到远裁减面的空间距离， n 表示视点到近裁减面的空间距离， z 表示视点到顶点的空间距离， N 表示 Z  值精度。

            "大多数人所忽略的是， z buffer 中存放的 z 值不一定是线性变化的。在正投影中同一图元相邻像素的 Z 值是线性关系的，但在透视投影中却不是的。在透视投影中这种关系是非线性的，而且非线性的程度随着空间点到视点的距离增加而越发明显"

            Z 精度之所以重要，是因为 Z 值决定了物体之间的相互遮挡关系，如果没有足够的精度，则两个相距很近的物体将会出现随机遮挡的现象，这种现象通常称为 “flimmering” 或 ”Z-fighting” 。
        }
        2.4.3 Stencil Buffer
        {
            Stencil buffer, 中文翻译为 “ 模板缓冲区 ” ，它是一个额外的 buffer ，通常附加到 z buffer 中
            每个像素对应一个 stencil buffer( 其实就是对应一个 Z buffer) 。 Z buffer 和 stencil buffer 通常在显存中共享同一片区域。 

            Stencil buffer，对大部分人而言应该比较陌生，这是一个用来 “ 做记号 ” 的 buffer ，例如:在一个像素的 stencil buffer 中存放 1 ，表示该像素对应的空间点处于阴影体（ shadow volume ）中。
        }
        2.4.4 Frame Buffer
        {
            Frame buffer ，称为帧缓冲器，用于存放显示输出的数据，这个 buffer 中的数据一般是像素颜色值。 Frame buffer 有时也被认为是 color buffer （颜色缓冲器）和 z buffer 的组合

            frame buffer通常都在显卡上，但是有时显卡会集成到主板上，所以这种情况下 frame buffer被放在内存区域（ general main memory ）。
        }
    2.5 本章小结
    {
        图形绘制管线是 GPU 编程的基础，事实上顶点着色程序和片段着色程序正是按照图形绘制管线而划分的。
        shader language 基于物体本身属性和光照条件，计算每个像素的颜色值。

    }
3、Shader Language
{
    shader language ，称为着色语言， shade 在英语是阴影、颜色深浅的意思

    在 GPU 编程发展的早期， shader language 的提出目标是加强对图形处理算法的控制，所以对该语言的定义亦针对于此。但随着技术的进步，目前的 shader language 早已经用于通用计算研究。

    shader language 被定位为高级语言，如， HLSL 的全称是 “High Level Shading
    Language” ， Cg 语言的全称为 “C for Graphic” ，并且这两种 shader language 的语
    法设计非常类似于 C 语言。不过高级语言的一个重要特性是 “ 独立于硬件 ” ，在这
    一方面 shader language 暂时还做不到， shader language 完全依赖于 GPU 构架，
    这一特征在现阶段是非常明显的！任意一种 shader language 都必须基于图形硬
    件，所以 GPU 编程技术的发展本质上还是图形硬件的发展。在 shader language
    存在之前，展示基于图形硬件的编程能力只能靠低级的汇编语言。

    目前， shader language 的发展方向是设计出在便捷性方面可以和 C++\JAVA
    相比的高级语言， “ 赋予程序员灵活而方便的编程方式 ” ，并 “ 尽可能的控制渲染
    过程 ” 同时 “ 利用图形硬件的并行性，提高算法的效率 ” 。 Shader language 目前主
    要有 3 种语言:基于 OpenGL 的 GLSL ，基于 Direct3D 的 HLSL ，还有 NVIDIA
    公司的 Cg  语言。
}
    3.1 Shader Language原理
    {
        使用Shader Language编写的程序称为Shader Program（着色程序）
        GPU 上的两个组件： Programmable Vertex Processor （可编程顶点处理器，又称为顶点着色器）和 Programmable Fragment Processor （可编程片段处理器，又称为片段着色器）
        顶点和片段处理器被分离成可编程单元，可编程顶点处理器是一个硬件单元，可以运行顶点程序，而可编程片段处理器则是一个可以运行
        片段程序的单元。

        顶点和片段处理器都拥有非常强大的并行计算能力，并且非常擅长于矩阵
        （不高于 4 阶）计算，片段处理器还可以高速查询纹理信息（目前顶点处理器还
        不行，这是顶点处理器的一个发展方向）。

         Vertex program 负责顶点坐标变换； Fragment program负责像素颜色计算；前者的输出是后者的输入
         输入寄存器存放输入的图元信息；输出寄存器存放处理后的图元信息；纹理 buffer 存放纹理数据，目前大多数的可编程图形硬件只支持片段处理器处理纹理；从外部宿主程序输入的常量放在常量寄存器中；临时寄存器存放着色程序在执行过程中产生的临时数据。
    }
    3.2 Vertex Shader Program
    {
            顶点着色程序从 GPU 前端模块（寄存器）中提取图元信息（顶点位置、法
        向量、纹理坐标等），并完成顶点坐标空间转换、法向量空间转换、光照计算等
        操作，最后将计算好的数据传送到指定寄存器中；然后片断着色程序从中获取需
        要的数据，通常为 “ 纹理坐标、光照信息等 ” ，并根据这些信息以及从应用程序传
        递的纹理信息（如果有的话）进行每个片断的颜色计算，最后将处理后的数据送
        光栅操作模块。
        
        顶点着色程序和片段着色程序通常是同时存在，相互配合，前者的输出作为后者的输入。不过也可以只有顶点着色程序。如果只有顶点着色程序，那么只对输入的顶点进行操作，而顶点内部的点则按照硬件默认的方式进行自动插值。例如:输入一个三角面片，顶点着色程序对其进行phong光照计算，只计算三个顶点的光照颜色，而三角面片内部点的颜色按照硬件默认的算法（ Gourand 明暗处理或者快速 phong 明暗处理）进行插值，如果图形硬件比较先进，默认的处理算法较好（快速 phong 明暗处理），则效果也会较好；如果图形硬件使用 Gourand 明暗处理算法，则会出现马赫带效应（条带化）

        片段着色程序是对每个片段进行独立的颜色计算，并且算法由自己编写，不但可控性好，而且可以达到更好的效果。

    }
    3.3 Fragment Shader Program
    {
        顶点着色程序主要进行几何方面的运算，而片段着色程序主要对最终的颜色值进行计算。
        片段着色程序还有一个显著的特点是:拥有检索纹理的能力。对于GPU而言，纹理相当于数组，这就意味着，如果要做通用计算，例如数组排序、字符串检索等就必须使用到片段着色程序。让顶点着色程序也拥有检索纹理的能力，是目前的一个研究方向。

        什么是片段？片段和像素有什么不一样？所谓片段就是所有的三维顶点在光栅化之后的数据集合，这些数据还没有经过深度值比较，而屏幕显示的像素都是经过深度比较的
    }
    3.4 CG VS GLSL VS HLSL
    {
        Shader language 目前有 3 种主流语言:基于 OpenGL 的 GLSL （ OpenGL
        Shading Language ，也称为 GLslang ），基于 Direct3D 的 HLSL （ High Level Shading
        Language ），还有 NVIDIA 公司的 Cg  （ C for Graphic ）语言

        
    }
    3.5 本章小结
4、Cg语言概述
    4.1 开始Cg之旅
    4.2 CG特性
    4.3 CG编译
        4.3.1 CG编译原理
        {
            计算机只能理解和执行由 0 、 1 序列（电压序列）构成的机器语言，所以汇
            编语言和高级语言程序都需要进行翻译才能被计算机所理解，担负这一任务的程
            序称为语言处理程序，通常也被称为编译程序。例如 C 或者 C++  编写的程序，
            需要首先编译成可执行文件（ .exe 文件），然后才能在 GPU 上运行，且一旦编译
            后，除非改变程序代码，否则不需要重新编译，这种方式称为静态编译（ static
            coompilation ）。静态编译最重要的特征是:一旦编译为可执行文件，在可执行文
            件运行期间不再需要源码信息。而动态编译（ dynamic compilation ）与之相反，
            编译程序和源码都要参与到程序的运行过程中。

            CG语言通常采用动态编译的方式，即，在宿主程序运行时利用Cg运行库（Cg Runtime library）动态编译Cg代码，使用动态编译的方式，可以将Cg程序当作一个脚本，随时修改随时运行，节省大量时间，在OGRE图形引擎中就是采用这种方法。

            Cg 语言同样支持静态编译方式
            Cg 源码编译成汇编代码后，这部分目标代码被链接到宿主程序最后的可执行程序中。使用静态编译的好处是只要发布可执行文件即可，源码不会被公开。

            Cg 编译器首先将 Cg 程序翻译成可被图形 API （ OpenGL 和 Direct3D ）所接
            受的形式，然后应用程序使用适当的 OpenGL 和 Direct3D 命令将翻译后的 Cg 程
            序传递给图形处理器， OpenGL 和 Direct3D 驱动程序最后把它翻译成图形处理器
            所需要的硬件可执行格式。 NVIDIA 提供的 Cg 编译器为 cgc.exe 。

            Cg程序的编译不依赖于宿主程序所使用的三维编程接口，而是依赖于图形硬件环境，因为图形硬件自身的限制，不一定支持某种Cg语句。

            被特定的图形硬件环境或 API 所支持的 Cg 语言子集，被称为 Cg Profiles 
            需要注意的是：profile分为顶点程序的profile和片段程序的profile，这是因为顶点着色器和片段着色器原本就不是工作在同一个硬件。

            Cg Profiles是Cg语言的重要组成部分，在使用Cg语言编写着色程序时，首先要考虑的一点就是“当前的图形硬件环境支持哪个Cg Profile”，这直接关系到所编写的着色程序是否可以在当前的图形硬件上运行。

        }
        4.3.2 CGC编译命令
        {
            Cg 程序编译的命令形式为
            cgc [options] file
            [options]表示可选配置项，file 表示 Cg 程序文件名。可选配置项包括编译时选择使用的 profile、着色程序的入口函数名称，以及着色程序文件名。

            例如：cgc –profile glslv –entry main_v test.cg
            -profile是profile配置项名；glslv是当前所使用的profile名称；-entry
            着色程序的入口函数名称配置项；main_v 是顶点着色程序的入口函数名；
            test.cg 是当前的着色程序文件名。编译器指定的着色程序入口函数名默认为
            main，通常为了将顶点\片段着色程序入口函数名区别开来，而并不使用默认名
            称。在下面所有的例子中，main_v 表示顶点着色程序入口函数名,main_f 表示片
            段着色程序入口函数名。

            注意：

                1、着色程序分为顶点着色程序和片段着色程序， profile 也分为顶点 profile 和片段 profile ，所以编译顶点着色程序时必须选用当前图形硬件支持的顶点profile ，同理，编译片段着色程序时必须选用当前图形硬件支持的片段profile 。

                下面所示使用片段 profile fp20 编译顶点着色程序是不对的。
                cgc –profile fp20 glslv –entry main_v test.cg

                如果您的着色程序中同时存在顶点着色程序和片段着色程序，在编译前切记分别选择各自的 profile 。

                2、选择 profile  如果不被当前图形硬件所支持，编译时会出现错误。被编译的
                着色程序中，如果存在不被所选择的 profile 所支持的语句，则编译时会出现
                错误。
                例如， tex2D(sampler2D tex , float3 sz ,float2 dsdx , float2 dsdy ) 不被 fp20所支持，
                如果你的编译形式为：
                cgc –profile fp20 –entry main_f test.cg
                则会出现错误提示信息：
                error C3004: function “tex2D” not supported in this profile 。
                改用 fp30 ，进行编译就会通过。
                cgc –profile fp30 –entry main_f test.cg

                尤其需要注意的是，循环语句 for,while 只被 vs_2_x, vp30, vp40,fp40 等少量的
                profiles 所支持

                这句话的意思是 “ 在其他的 profiles 中， for 和 while 循环只有当确切的知道循环次数时才能被使用 ” 。但经过试验，通常在其他 profiles 编译含义 for,while 语句时会出现错误提示信息:
                
                error c6003 : instruction limit of exceeded……
                因此，如果没有确切的把握，不要在低级的 profiles 中使用循环控制语句。

                3、被编译的着色程序文件名必须加上 .cg 后缀。如果没有加后缀，写成如下的形式:
                cgc –profile glslv –entry main_v
                则会出现错误提示信息:
                fatal error C9999: Can’t open file:test

                4、另外 cgc 还提供一种比较特殊的功能：
                就是将 Cg 语言所写的着色程序转换为使用 GLSL 或 HLSL 所编写的程序。例如，将代码写成如下形式，表示编译文件 test.cg 中的顶点着色程序，入口函数名为 main_v ，并将顶点着色程序转换为 glsl 程序，然后保存成文件 direct.glsl 。

                cgc –profile glslv –o direct.glsl –entry main_v test.cg

                5、还有一个非常隐蔽的编译情况是：如果着色程序中的某些变量并没有为最终
                的输出做出贡献，则编译时会将该部分代码忽略（会检查语法错误，但并不
                编译成汇编代码）。通常这一点不会造成太大的影响，但是如果这些变量刚
                好是从外部宿主程序中传入的变量，并且在着色程序中没有被使用，则宿主
                50
                程序传入变量的接口函数可能会报错 “ 找不到该变量 ” 。这种情况比较少遇
                到，但并非不存在，且一旦遇上问题的原因难以查明，故而我在此写上，希
                望可以有所帮助。

                基于 GPU 编程，最令人崩溃的一点是：无法跟踪调试着色程序！这一点目前还没有解决方案出现。对于一个着色程序，语法错误可以通过编译器发现，而代码逻辑错误只能是人为查找。常会遇到这种情况，一段代码编译通过，但是运行结果不在预期之中，如果是 C++\JAVA 程序就可以进行跟踪调试，但是着色程序不能被调试，只能一行代码一行代码的进行逻辑分析。所以，编译着色程序要非常注意逻辑的严密性，和代码的组织结构，这是为了更加容易的暴露错误和维护代码。一个良好的习惯是加入注释语句。

        }
    4.4 CG Profiles
    {
         Profile 按照功能可以划分为顶点Profile 和片断 Profile ，而顶点 profile 和片段 profile 又基于 OpenGL 和 DirectX 的不同版本或扩展，划分为各种版本。

         当前 Cg compiler 所支持的 profiles 有：
        ?  OpenGL ARB vertex programs
        Runtime profile: CG_PROFILE_ARBVP1
        Compiler option: _profile arbvp1
        ?  OpenGL ARB fragment programs
        Runtime profile: CG_PROFILE_ARBFP1
        Compiler option: _profile arbfp1
        51
        ?  OpenGL NV40 vertex programs
        Runtime profile: CG_PROFILE_VP40
        Compiler option: _profile vp40
        ?  OpenGL NV40 fragment programs
        Runtime profile: CG_PROFILE_FP40
        Compiler option: _profile fp40
        ?  OpenGL NV30 vertex programs
        Runtime profile: CG_PROFILE_VP30
        Compiler option: _profile vp30
        ?  OpenGL NV30 fragment programs
        Runtime profile: CG_PROFILE_FP30
        Compiler option: _profile fp30
        ?  OpenGL NV2X vertex programs
        Runtime profile: CG_PROFILE_VP20
        Compiler option: _profile vp20
        ?  OpenGL NV2X fragment programs
        Runtime profile: CG_PROFILE_FP20
        Compiler option: _profile fp20
        ?  DirectX 9 vertex shaders
        Runtime profiles: CG_PROFILE_VS_2_X
        CG_PROFILE_VS_2_0
        Compiler options:-profile vs_2_x
        -profile vs_2_0
        ?  DirectX 9 pixel shaders
        Runtime profiles: CG_PROFILE_PS_2_X
        CG_PROFILE_PS_2_0
        Compiler options: -profile ps_2_x
        -profile ps_2_0
        ?  DirectX 8 vertex shaders
        Runtime profiles: CG_PROFILE_VS_1_1
        52
        Compiler options:-profile vs_1_1
        ?  DirectX 8 pixel shaders
        Runtime profiles: CG_PROFILE_PS_1_3
        CG_PROFILE_PS_1_2
        CG_PROFILE_PS_1_1
        Compiler options: -profile ps_1_3
        -profile ps_1_2
        -profile ps_1_2
        -profile ps_1_1
        附：截止到 2009 年 10 月，出现的 profile 已经不止上面这些种类了，尤其
        是现在 DirectX 已经出到了 11 的版本。上面的 profile 是可以在当前大多数机器
        上使用的。
    }
5、CG数据类型
{
    本章将着重介绍Cg语言中预定义的内置（ built in ）的、或称为基本（ primitive ）
    的数据类型。然后介绍可以用来声明对象的各类类型，主要是数组和结构类型。
    学习本章时，需要体会内置向量类型和数组类型的区别。
}
    5.1 基本数据类型
    {
        Cg 支持 7 种基本的数据类型：
        1. float ， 32 位浮点数据，一个符号位。浮点数据类型被所有的 profile 支持（但是 DirectX8 pixel profiles 在一些操作中降低了浮点数的精度和范围）；
        2. half ， 16 为浮点数据；
        3. int ， 32 位整形数据，有些 profile 会将 int 类型作为 float 类型使用；
        4. fixed ， 12 位定点数，被所有的 fragment profiles 所支持；
        5. bool, 布尔数据，通常用于 if 和条件操作符（ ?: ），布尔数据类型被所有的profiles 支持；

        6. sampler*, 纹理对象的句柄（ the handle to a texture object ），分为 6 类：
        sampler, sampler1D, sampler2D, sampler3D, samplerCUBE, 和 samplerRECT 。
        DirectX profiles 不支持 samplerRECT 类型，除此之外这些类型被所有的 pixel
        profiles 和 NV40 vertex program profile 所支持（ CgUsersManual 30 页）。由
        此可见，在不远的未来，顶点程序也将广泛支持纹理操作；

        7. string ，字符类型，该类型不被当前存在的 profile 所支持，实际上也没有
        必要在 Cg 程序中用到字符类型，但是你可以通过 Cg runtime API 声明该类
        型变量，并赋值；因此，该类型变量可以保存 Cg 文件的信息。

        前 6 种类型会经常用到，事实上在 Wikipedia 有关 Cg 语言的阐述中只列举
        了前 6 种类型，而并没有提到 string 数据类型。除了上面的基本数据类型外， Cg
        还提供了内置的向量数据类型 (built-in vector data types) ，内置的向量数据类型基
        于基础数据类型。例如：float4，表示 float 类型的 4 元向量；bool4，表示 bool
        类型 4 元向量。
        注意：向量最长不能超过 4 元，即在 Cg 程序中可以声明 float1 、 float2 、 float3 、
        float4 类型的数组变量，但是不能声明超过 4 元的向量

        注意： Cg 中向量、矩阵与数组是完全不同，向量和矩阵是内置的数据类型
        （矩阵基于向量），而数组则是一种数据结构，不是内置数据类型！这一点和
        C\C++ 中不太一样，在 C\C++ 中，这三者同属于数据结构，数组可以构建向量和
        矩阵。

    }
    5.2 数组类型
    {
        在着色程序中，数组通常的使用目的是：作为从外部应用程序传入大量参数到 Cg 的顶点程序中的形参接口，例如与皮肤形变相关的矩阵数组，或者光照参数数组等。

        Cg中声明数组变量的方式和C语言类似:例如:
        float a[10];//声明一个数组，包含10个float类型数据
        float4 b[10];//声明一个数组，包含10个float4类型响亮数据
        初始化：
        float a[4] = {1.0,2.0,3.0,4.0};可以调用".length"来获取数组长度
        多维数组：
        float b[2][3] = {{0.0,0.0,0.0},{1.0,1.0,1.0}};
        int length1 = b.length;//length1 = 2;
        int length2 = b[0].length;//length2 = 3
        数组和矩阵有些类似，但是并不是相同。
        4*4阶数组 float M[4][4]
        4阶矩阵 float4x4 M

        进行数组变量声明时，一定要指定数组长度，除非是作为函数参数而声明的形参数组。并且在当前的 profiles 中，数组的长度和所引用的数组元素的地址必须在编译时就知道
    }
    5.3 结构类型
    {
        Shader语言的方展趋势还是向着具有面向对象特性的高级语言，不过目前的Cg语言中的结构体以展现“封装”为主，并不支持继承机制。
        注意：在当前的所有的profile版本下，如果结构体的一个成员函数使用了成员变量，则该成员变量要声明在前。此外，成员函数是否可以重载依赖于使用的profile版本。

        一般来说 ,Cg 的源代码都会在文件首部定义二个结构体，分别用于定义输人和输出的类型，这二个结构体定义与普通的 C 结构定义不同，除了定义结构体成员的数据类型外，还定义了该成员的绑定语义类型 ( Binding Semantics) ，所谓绑定语义类型是为了与宿主环境进行数据交换的时候识别不同数据类型的。

        目前Cg支持的绑定语义类型包括 POSTION位置 COLOR颜色 NORMAL法向量 TEXCOORD纹理坐标

        当顶点着色程序向片段着色程序传递的数据类型较多的情况下，使用结构体可以大大的方便代码的编写和维护。

    }
    5.4 接口（Interfaces）类型
    {
        Cg 语言提供接口类型，但Cg 语言中的接口类型还不完善，不能被扩展和包含
        此外，目前的GPU 编程大多只是针对独立的算法进行编码，规模较小，使用接口类型没有太大的优势
    }
    5.5 类型转换
    {
        Cg 中的类型转换和 C 语言中的类型转换很类似
        C 语言中类型转换可以是强制类型转换，也可以是隐式转换，如果是后者，则数据类型从低精度向高精度转换
        当有类型变量和无类型常量数据进行运算时，该常量数据不做类型转换
        Cg 语言中对于常量数据可以加上类型后缀，表示该数据的类型
        f表示float
        h表示half
        x表示fixed
    }
6、CG表达式与控制语句
{
    CG中的操作符与C语言中的类似（操作符的功能和写法与C相同，但是用法不尽相同），按照操作符的功能可以划分为:关系操作符、逻辑操作符、条件操作符。
    CG中有一类较为特殊的操作符，称为Swizzle操作符，这个操作符用于取出向量类型中的分量。此外，与C语言不同的是，CG允许在向量类型变量上使用操作符，例如>操作符可以用来比较两个向量各个分量的大小关系

}
    6.1 关系操作符（Comparison Operators）
    {
        关系操作符，用于比较同类型数据（不同类型的基础数据需要进行类型转换，
        不同长度的向量，不能进行比较）之间的大小关系或者等价关系。

        在 Cg 中，由于关系操作符以及下节会讲到的逻辑操作符，都返回 bool 类型结果，所以这两种操作符有时也被统一称为 boolean operator 。

        Cg 语言表达式允许对向量使用所有的 boolean operator ，如果是二元操作符，
        则被操作的两个向量的长度必须一致。表达式中向量的每个分量都进行一对一的
        运算，最后返回的结果是一个 bool 类型的向量，长度和操作数向量一致。例如:
        float3 a = float4(0.5, 0.0, 1.0);
        float3 b = float4(0.6, -0.1, 0.9);
        bool3 c = a<b;
        运算后向量 c 的结果为 float3(true, false, true);

    }
    6.2 逻辑操作符（Logical Operators）
    {
        Cg 语言中有 3 种逻辑操作符 ( 也被称为 boolean Operators) 

        && 逻辑与
        || 逻辑或
        !  逻辑非

        逻辑操作符也可以对向量使用，返回的变量类型是同样长度的内置 bool 向量。

        有一点需要注意： Cg 中的逻辑与（ && ）和逻辑或（ || ）不存在 C 中的短路现象（ short-circuiting ，即只用计算一个操作数的 bool 值即可），而是参与运算的操作数据都进行 bool 分析。
    }
    6.3 数学操作符（Math Operators）
    {
        [Cg 语言对向量的数学操作提供了内置的支持]， Cg 中的数学操作符有: * 乘法；/ 除法； - 取反； + 加法；—减法； % 求余； ++ ；——； *= ； /= ； += ； -= ；后面四种运算符有时被归纳入赋值操作符，不过它们实际上进行数学计算，然后进行赋值，

        需要注意的是：求余操作符 % 。只能在 int 类型数据间进行，否则编译器会提示错误信息: error C1021: operands to  “ % ” must be integral.

        当使用这些数学操作符对一个标量和一个向量进行运算时，标量首先被复制到一个长度相同的向量中，然后进行运算
    }
    6.4 移位操作符
    {
        Cg 语言中的移位操作符，功能和 C 语言中的一样，也可以作用在向量上，但是向量类型必须是 int 类型。

        int2 a = int2(0.0,0.0);
        int2 b = a>>1;

        如果使用如下代码，会出现错误提示信息： 
        error C1021:operands to  “ shr ”must be integral.
        float2 a = int2(0.0,0.0);
        float2 b = a>>1;
    }
    6.5 Swizzle操作符
    {
        可以使用 Cg 语言中的 swizzle 操作符（ . ）将一个向量的成员取出组成一个新的向量。 swizzle 操作符被 GPU 硬件高效支持。 swizzle 操作符后接 x 、 y 、 z 、 w ，分别表示原始向量的第一个、第二个、第三个、第四个元素； swizzle 操作符后接r 、 g 、 b 和 a 的含义与前者等同。不过为了程序的易读性，建议对于表示颜色值的向量，使用 swizzle 操作符后接 r 、 g 、 b 和 a 的方式。

        float4(a, b, c, d).xyz 等价于 float3(a, b, c)
        float4(a, b, c, d).xyy 等价于 float3(a, b, b)
        float4(a, b, c, d).wzyx 等价于 float4(d, c, b, a)
        float4(a, b, c, d).w 等价于 float d

        值得注意的是， Cg 语言中 float a  和 float1 a是基本等价的，两者可以进行类型转换

        float 、 bool 、 half 等基本类型声明的变量也可以使用 swizzle 操作符。
        float a = 1.0;
        float4 b = a.xxxx;

        注意： swizzle 操作符只能对结构体和向量使用，不能对数组使用，如果对数组使用 swizzle 操作符则会出现错误信息: error C1010: expression left of . ” x ” is not a struct or array 
        要从数组中取值必须使用 [] 符号

        float a[3] = {1.0,1.0,0.0};
        float b = a[0]; //正确
        float c = a.x; //编译会提示错误信息
    }
    6.6 条件操作符（Conditional Operators）
    {
        条件操作符的语法格式为：
        expr1 ? expr2 : expr3;
        expr1 的计算结果为 true 或者 flase ，如果是 true, 则 expr2 执行运算，否则 expr3
        被计算。
        条件操作符为简单的 if-else 语句提供了一种便利的替代方式，例如我们可以
        不必写：
        if(a < 0){b = a}
        else{c = a}
        而改写为：
        （ a < 0 ） ?(b = a) :( c = a);

        Cg 中的条件操作符一个独特的性能是：支持向量运算。即， expr1 的计算结果可以是 bool 型向量， expr2 和 expr3 必须是与 expr1 长度相同的向量。

        float3 h = float3(-1.0,1.0,1.0);
        float3 i = float3(1.0,0.0,0.0);
        float3 g = float3(1.0,1.0,0.0);
        float3 k;
        k = (h < float3(0.0,0.0,0.0))?(i):(g);

        三元向量 h 与 float3(0.0, 0.0, 0.0) 做比较运算后结果为（ true, false, false ） , 所
        以 i 的第一个数据赋值给 K 的第一个数据， g 的第二个和第三个数据赋值给 k 的第二
        个和第三个数据， K 的值为 (1.0, 1.0, 0.0) 
    }
    6.7 操作符优先顺序
    {
        Cg 教程 _ 可编程实时图形权威指南第 3.3.1 节
    }
    6.8 控制流语句（Control Flow Statement）
    {
        程序最小的独立单元是语句（ statement ），语句一般由分号结尾，缺省情况
        下，语句是顺序执行的，但是当涉及逻辑判断控制时，就要求有控制流程序语句。
        控制流程序语句分为条件语句和循环语句,在 C 语言中，条件语句有 if 、 if-else 、
        switch 等，而循环过程则由 while 、 do-while 和 for 语句支持。 Cg 中的控制流语句和
        循环语句与 C 语言类似：条件语句有： if 、 if-else ；循环语句有： while 、 for 。 break
        语句可以和在 for 语句中使用。

        Cg 语言中的控制流语句要求其中的条件表达式返回值都是 bool 类型，这一点
        是与 C 语言不同之处（ C 语言中，条件表达式返回值可以是 0 、 1 ）

        vs_2_x, vp30 和 vp40 这些 profile 支持分支指令（又称转移指令， branch
        instruction ）， for 和 while 循环指令在这些 profile 中被完全支持

        “ In other profiles, for and while loops may only be used if the compiler can
        fully unroll them (that is, if the compiler can determine the iteration count at compile
        time) ”。
        这句话的意思是“在其他的 profiles 中， for 和 while 循环只有当确切的知道循
        环次数时才能被使用”。但经过试验，如果使用“在 fp40 和 ps_3_0 之前的”片段
        profiles 编译含义 for, while 语句时会出现错误提示信息： error c6003 ： instruction
        limit of exceeded ……。因此，如果没有确切的把握，不要在低级的 profiles 中使用
        循环控制语句。

        同样， return 只能作为最后一条语句出现。函数的递归调用（ recursion ）在
        Cg 语言中是被禁止的。 Switch  、 case 和 default 在 Cg 中作为保留关键字存在，但
        是它们目前不被任何 profile 所支持。
    }
7、输入\输出与语义绑定
{
    GPU 运行原理和数据流程的角度阐述顶点着色程序和片段着色程序的输入输出
    应用程序（宿主程序）将图元信息（顶点位置、法向量、纹理坐标等）传递给顶点着色程序；顶点着色程序基于图元信息进行坐标空间转换，运算得到的数据传递到片段着色程序中；片段着色程序还可以接受从应用程序中传递的纹理信息，把这些信息综合起来计算每个片段的颜色值，最后将这些颜色值输送到帧缓冲区（或颜色缓冲区）中。

    这些是顶点着色程序和片段着色程序的基本功能和数据输入输出，实际上现
    在的着色程序已经可以接受多种数据类型，并灵活的进行各种算法的处理，如，
    可以接受光源信息（光源位置、强度等）、材质信息（反射系数、折射系数等）、
    运动控制信息（纹理投影矩阵、顶点运动矩阵等），可以在顶点程序中计算光线
    的折射方向，并传递到片段程序中进行光照计算。

    1. 从应用程序传递到 GPU 的数据，分为图元信息数据（在GPU处理的基本数
    据如顶点位置信息等）和其他的离散数据（在GPU运行流程中不会发生变化，
    如材质对光的反射、折射信息），这两种输入数据如何区分？

    2. 从应用程序传递到GPU中的图元信息如何区分类型，即，顶点程序怎么知
    道一个数据是位置数据，而不是法向量数据？

    3. 顶点着色程序与片段着色程序之间的数据传递如何进行？

}
    7.1 Cg关键字
    {
            Cg 中的关键字很多都是照搬 C\C++ 中的关键字，不过 Cg 中也创造了一系列独特的关键字，
        这些关键字不但用于指定输入图元的数据含义（是位置信息，还是法向量信息），
        本质也则对应着这些图元数据存放的硬件资源（寄存器或者纹理），称之为语义
        词（ Semantics ），通常也根据其用法称之为绑定语义词（ binding semantics ）。

        除语义词外， Cg 中还提供了三个关键字， in 、 out 、 inout ，用于表示函数的
        输入参数的传递方式，称为输入 \ 输出关键字，这组关键字可以和语义词合用表
        达硬件上不同的存储位置，即同一个语义词，使用 in 关键字修辞和 out 关键词修
        辞，表示的图形硬件上不同的寄存器。

        Cg 语言还提供两个修辞符： uniform ，用于指定变量的数据初始化方式； const
        关键字的含义与 C\C++ 中相同，表示被修辞变量为常量变量。
    }
    7.2 uniform
    {
        Cg 语言将输入数据流分为两类

        1.  Varying inputs ,即数据流输入图元信息的各种组成要素。从应用程序输入
        到 GPU 的数据除了顶点位置数据，还有顶点的法向量数据，纹理坐标数据
        等。 Cg 语言提供了一组语义词，用以表明参数是由顶点的哪些数据初始化
        的。

        2.  Uniform inputs ，表示一些与三维渲染有关的离散信息数据，这些数据通
        常由应用程序传入，并通常不会随着图元信息的变化而变化，如材质对光的
        反射信息、运动矩阵等。 Uniform 修辞一个参数，表示该参数的值由外部应
        用程序初始化并传入；例如在参数列表中写：

        uniform float brightness,
        uniform float4x4 modleWorldProject

        表示从“外部”传入一个 float 类型数据，和一个 4 阶矩阵。“外部”的含义
        通常是用 OpenGL 或者 DirectX 所编写的应用程序。

        使用 Uniform 修辞的变量，除了数据来源不同外，与其他变量是完全一样的。

        需要注意的一点是： uniform 修辞的变量的值是从外部传入的，所以在 Cg 程
        序（顶点程序和片段程序）中通常使用 uniform 参数修辞函数形参，不容许声明
        一个用 uniform 修辞的局部变量！否则编译时会出现错误提示信息：
        Error C5056:’uniform’not allowed on local variable
    }
    7.3 const
    {
        Cg 语言也提供 const 修辞符，与 C\C++ 中含义一样，被 const 所修辞的变量
        在初始化之后不能再去改变它的值。

        const float a = 1.0;
        a = 2.0; //错误
        float b = a++; //错误

        编译时会出现错误提示信息： error C1026: assignment to const variable 。

        const 修辞符与 uniform 修辞符是相互独立的，对一个变量既可以单独使用
        const 或者 uniform ，也可以同时使用。
    }
    7.4 输入\输出修辞符（in\out\inout）
    {
        参数传递是指：函数调用实参值初始化函数形参的过程。

        在 C\C++ 中，根据
        形参值的改变是否会导致实参值的改变，参数传递分为 “ 值传递（ pass-by-value ） ”
        和 “ 引用传递（ pass-by-reference ） ” 。按值传递时，函数不会访问当前调用的实参，
        函数体处理的是实参的拷贝，也就是形参，所以形参值的改变不会影响实参值；
        引用传递时，函数接收的是实参的存放地址，函数体中改变的是实参的值。 C\C++
        采取指针机制构建引用传递，所以通常引用传递也称为 “ 指针传递 ” 。

        Cg 语言中参数传递方式同样分为 “ 值传递 ” 和 “ 引用传递 ” ，但指针机制并不
        被 GPU 硬件所支持，所以 Cg 语言采用不同的语法修辞符来区别 “ 值传递 ” 和 “ 引
        用传递 ” 。这些修辞符分别为：

        1.  in : 修辞一个形参只是用于输入，进入函数体时被初始化，且该形参值
        的改变不会影响实参值，这是典型的值传递方式。

        2.  out : 修辞一个形参只是用于输出的，进入函数体时并没有被初始化，这
        种类型的形参一般是一个函数的运行结果；

        3.  inout : 修辞一个形参既用于输入也用于输出，这是典型的引用传递。

        举例如下：

        void myFunction(out float x); //形参 x，只是用于输出
        void myFunction(inout float x); //形参 x，即用于输入时初始化，也用于输出数据
        void myFunction(in float x); //形参 x，只是用于输入
        void myFunction(float x); /等价与 in float x，这种用法和 C\C++完全一致

        也可以使用 return 语句来代替 out 修辞符的使用。输入 \ 输出修辞符通常和语
        义词一起使用，表示顶点着色程序和片段着色程序的输入输出。
    }
    7.5 语义词（Semantic）与语义绑定（Binding Semantics）
    {
        语义词，表示输入图元的数据含义（是位置信息，还是法向量信息），也表
        明这些图元数据存放的硬件资源（寄存器或者纹理缓冲区）。顶点着色程序和片
        段着色程序中 Varying inputs 类型的输入，必须和一个语义词相绑定，这称之为
        绑定语义（ binding semantics ）。
    }
        7.5.1 输入语义与输出语义的区别
        {

            语义概念的提出和图形流水线工作机制大有关系。

            顶点处理器的输入数据是处于模型空间的顶点
            数据（位置、法向量），输出的是投影坐标和光照颜色；片段处理器要将光照颜
            色做为输入，问题是 “ 片段处理器怎么知道光照颜色值的存放位置 ” ？

            由于 Cg 语言并不支持指针机制，且图
            形硬件处理过程中，数据通常暂存在寄存器中，故而在 Cg 语言中，通过引入语
            义绑定（ binding semantics ）机制，指定数据存放的位置，实际上就是将输入 \ 输
            出数据和寄存器做一个映射关系（在 OpenGL Cg profiles 中是这样的，但在
            DirectX-based Cg profiles 中则并没有这种映射关系）。

            根据输入语义，图形处理
            器从某个寄存器取数据；然后再将处理好的数据，根据输出语义，放到指定的寄
            存器。

            语义，是两个处理阶段（顶点程序、片段程序）之间的输入 \
            输出数据和寄存器之间的桥梁，同时语义通常也表示数据的含义，如 POSITION
            一般表示参数种存放的数据是顶点位置。

            语义，只对两个处理阶段的输入 \ 输出数据有意义，也就是说，语义只有在
            入口函数中才有效，在内部函数（一个阶段的内部处理函数，和下一个阶段没有
            数据传递关系）的无效，被忽略；

            语义，分为输入语义和输入语义；输入语义和输出语义是有区别的。

            例如：顶点 Shader 的输入参数， POSITION
            指应用程序传入的顶点位置，而输出参数使用 POSITION 语义就表示要反馈给硬
            件光栅器的裁剪空间位置，光栅器把 POSITION 当成一个位置信息。虽然两个语
            义都命名为 POSITION ，但却对应着图形流水线上不同的寄存器。

        }
        7.5.2 顶点着色程序的输入语义
        {
            POSITION BLENDWEIGHT
            NORMAL TANGENT
            BINORMAL PSIZE
            BLENDINDICES TEXCOORD0---TEXCOORD7

            这组绑定语义关键字被 Cg 语言的所有 vertex profile 所支持,
            一些 profile 支持额外的语义词。

            语义词 POSITION0 等价于 POSITION ，其他的语义词也有类似的等价关系。
            为了说明语义词的含义，举例如下：

            in float4 modelPos: POSITION
            表示该参数中的数据是的顶点位置坐标（通常位于模型空间），属于输入参
            数，语义词 POSITION 是输入语义，如果在 OpenGL 中则对应为接受应用程序传
            递的顶点数据的寄存器（图形硬件上）。

            “顶点位置坐标传入顶点着色程序中转化为四元向量，最后
            一元数据为 1 ，而顶点法向量传入顶点着色程序中转化为四元向量，最后一元数
            据为 0 。”
        }
        7.5.3 顶点着色程序的输出语义
        {
            顶点程序的输出数据被传入到片断程序中，所以顶点着色程序的输出语义
            词，通常也是片段程序的输入语义词，不过语义词 POSITION 除外。

            下面这些语义词适用于所有的 Cg vertex profiles 作为输出语义和 Cg fragment
            profiles 的输入语义： POSITION ， PSIZE ， FOG,COLOR0-COLOR1,
            TEXCOORD0-TEXCOORD7 。

            顶点着色程序必须声明一个输出变量，并绑定 POSITION 语义词，该变量中
            的数据将被用于，且只被用于光栅化！

            为了保持顶点程序输出语义和片段程序输入语义的一致性，通常使用相同的
            struct 类型数据作为两者之间的传递，这是一种非常方便的写法，推荐使用。

            注意：当使用 struct 结构中的成员变量绑定语义时，需要注意到顶点着色程
            序中使用的 POSITION 语义词，是不会被片段程序所使用的。

            如果需要从顶点着色程序向片段程序传递数据，例如顶点投影坐标、光照信
            息等，则可以声明另外的参数，绑定到 TEXCOORD 系列的语义词进行数据传递，
            实际上 TEXCOORD 系列的语义词通常都被用于从顶点程序向片段程序之间传递
            数据

            当然，你也可以选择不使用 struct 结构，而直接在函数形参中进行语义绑定。
            无论使用何种方式，都要记住 vertex program 中的绑定语义（ POSITION 除外）的
            输出形参中的数据会传递到 fragment program 中绑定相同语义的输入形参中。
        }
        7.5.4 片段着色程序的输出语义
        {
            片段着色程序的输出语义词较少，通常是 COLOR 。这是因为片段着色程序
            运行完毕后，就基本到了 GPU 流水线的末端了。 片段程序必须声明一个 out 向量
            （三元或四元），绑定语义词 COLOR ，这个值将被用作该片断的最终颜色值。

            一些 fragment profile 支持输出语义词 DEPTH ，与它绑定的输出变量会设置片
            断的深度值；还有一些支持额外的颜色输出，可以用于多渲染目标（ multiple
            render targets , MRTs ）。

            和顶点着色程序一样，片断着色程序也可以将输出对象放入一个结构体中。
            不过，这种做法未必方便，理由是：片断着色程序的输出对象少，最常用的就是
            颜色值（绑定输出语义词 COLOR ），单独的一个向量没有必要放到结构体中。
            而顶点着色程序输出的对象很多，在有些光照或阴影计算中，往往要输出顶点的
            世界坐标、法向量、光的反射方向、折射方向、投影纹理坐标等数据，这些数据
            统一放到结构体中方便管理。
        }
        7.5.5 语义绑定的方法
        {
            入口函数输入\输出数据的绑定语义有 4 四种方法

            1. 绑定语义放在函数的参数列表的参数声明后面中:

            [const] [in | out | inout]<type><identifier> [ :
            <binding-semantic>][=<initializer>]

            其中， const 作为可选项，修辞形参数据； in 、 out 、 inout 作为可选项，说
            明数据的调用方式； type 是必选项，声明数据的类型； identifier 是必选项，
            形参变量名；一个冒号 “ ： ” 加上一个绑定语义，是可选项；最后是初始化
            参数，是可选项。

            如下代码所示。形参列表中的参数一、参数二绑定到输
            入语义；参数三、参数四绑定到输出语义；尽管参数一和参数 3 的绑定语
            义词一样，但前者是输入语义，后者是输出语义，所以这两个参数数据所
            对应的硬件位置是不一样的。

            void mian_v(float4 position_obj : POSITION,
            float3 normal_obj : NORMAL,
            out float4 oPosition : POSITION,
            out float4 oColor : COLOR,
            uniform float4x4 modelViewProj)
            {
            ………………
            }

            2. 绑定语义可以放在结构体（ struct ）的成员变量后面

            struct <struct-tag>
            {
            <type><identifier> [:<binding-semantic >];
            };
            举例如下，结构 C2E1v_Outpu 中的 2 个成员变量分别绑定到语义 POSITION
            和 COLOR ，然后在 C2E1v_green 顶点程序入口函数中输出，所以 C2E1v_Outpu
            中的语义是输出语义。

            struct C2E1v_Output {
            float4 position : POSITION;
            float3 color : COLOR;
            };
            C2E1v_Output C2E1v_green(float2 position : POSITION)
            { 
            C2E1v_Output OUT;
            OUT.position = float4(position,0,1);
            OUT.color = float3(0,1,0);
            return OUT; 
            }

            3. 绑定语义词可以放在函数声明的后面，其形式为：
            <type> <identifier> (<parameter-list>) [:<binding-semantic]
            {
            <body>
            }
            如下代码所示，顶点入口函数的声明后带有“ COLOR ”语义词，表示该函
            数需要反馈一个颜色值，所以函数的返回类型为 float4 ，函数体也必须以 return
            语句结束。

            float4 main_v(float4 position: POSITION,
            out float4 oposition : POSITION,
            uniform float4x4 modelViewProj):COLOR
            {
            oposition = mul(modelViewProj,position);
            float4 ocolor = float4(1.0,0,0,0);
            return ocolor; 
            }

            4. 最后一种语义绑定的方法是，将绑定语义词放在全局非静态变量的声明后
            面。其形式为：
            <type> <identifier> [:<binding-semantic>][=<initializer>];
            这种形式的结构很不紧凑，也不利于代码的维护和阅读，所以并不常见，不建
            议读者使用。  
        }
8、函数与程序设计
    8.1 函数
    {
        函数可以被看作一个由用户定义的操作
        Cg 语言中的函数声明形式与C\C++ 中相同，由返回类型（ return type ）、函数名、形参列表（ parameter list ，位于括号中，并用逗号分隔的参数表）和函数体组成。

        函数体包含在花括号中。如果没有返回值，则函数的返回类型为void。

        void myFunc(inout float val )
        {
        ………………
        val += 10.0;
        }

        float myFunc(float vals[])
        {
        float sum = 0.0;
        ……………………..
        return sum;
        }

        注意：如果函数没有返回值，函数的返回类型一定要是 void ，否则编译会出
        现大量的错误，错误信息的大概形式是：
        error C0000: syntax error, unexpected’(’at token “(”
        error C0501: type name expected at token “(”
        error C1110: function “main_v” has no return statement
    }
        8.1.1 数组形参
        {
            在 C\C++ 中，当一个数组作为函数的形参时，实际上传入的只是指向首元素的指针，并且数组边界被忽略而CG语言中不存在指针机制（图形硬件不支持），数组作为函数形参，传递的是数组的完整拷贝。

            “The most important difference from C is that arrays are first-class types. That means array assignments actually copy the entire array, and arrays that are passed as parameters are passed by value, rather than by reference”.

            CG语言中的数组是“first-class types”，译为“第一类数据类型”，所谓的“第一类”的含义是，强调该类型数据是“不可分解的、最高级别的、不被重述的”，即“第一类型数据”和“基础数据类型”的概念是近同的。

            如有兴趣深入了解 “first-class” 概念，可参阅 Matthieu Sozeau and Nicolas Oury 所著的 “First-Class Type Classes” 一文

            数组类型变量作为函数形参，可以是一维的也可以是多维的，并且不必声明数组长度，即 Unsized Array 。

            float myFunc(float vals[])
            {
                float sum = 0.0;
                for(int i = 0;i < vals.length; i++)
                {
                    sum += vals[i];
                }
                return sum;
            }

            myFunc是一个函数，输入一个数组变量，计算数组中所有数据之和，然后返回float类型数据。
            请注意:数组形参不必指定长度。如果指定了函数中形参数组的长度，那么在调用该函数时实参数组的长度和形参数组长度必须保持一致，如果没有保持一致，就会出现编译错误:
            error C1102: incompatible type for parameter… 。

            float myFunc( float vals[3])
            {
            float sum = 0.0;
            for(int i = 0; i< vals.length; i++)
            {
            sum += vals[i];
            }
            return sum;
            }
            void main(…)
            {
            float a[2] = {0.0, 1.0};
            float b[3] = {0.0, 1.0, 2.0};
            myFunc(a); //错误调用，会导致编译错误
            myFunc(b); //正确调用
            }

            对于函数的形参数组最好不要指定长度，这样就可以片配任意长度的参数数组。
            如果函数的形参数组是多维数组，其声明方式和上面是一样的，可以不指定长度；如果指定形参数组长度，则实参数组长度必须保持一致。
        }
    8.2 函数重载
    {
        Cg 语言支持函数重载（ Functon Overlaoding ），其方式和 C++ 基本一致，通过形参列表的个数和类型来进行函数区分。

        bool function(float a, float b) {return ( a == b);}
        bool function(boo a, bool b) {return ( a == b);}

        Cg 语言标准函数库中绝大部分函数都被重载过。
    }
    8.3 入口函数
    {
        所谓入口函数，即一个程序执行的入口，例如 C\C++ 程序中的 main() 函数。

        通常高级语言程序中只有一个入口函数，不过由于着色程序分为顶点程序和片断程序，两者对应着图形流水线上的不同阶段，所以这两个程序都各有一个入口函数。

        顶点程序和片段程序有且只有一个入口函数，当程序进行编译时，需要指定入口函数名称，除非入口函数名为main。
        当我们编写或阅读 Cg代码时，如何区分哪个函数是入口函数呢？或者哪个入口函数对应着顶点程序或片段程序？

        事实上，顶点程序和片段程序的入口函数形式，已经完全由它们在渲染管线中所处的阶段所决定。

        在前面已经阐述过，顶点程序接收应用程
        序传递的顶点数据（通常位于模型坐标空间），然后进行坐标空间转换和光照处
        理，最后输出投影坐标和计算得到的光照颜色；而片段程序接收从顶点程序输出
        的数据，并进行像素颜色计算。在片段程序中往往涉及到纹理颜色的处理，其输
        入参数中常有纹理形参的声明。所以通过观察程序的输入输出语义绑定（参阅
        7.5 节语义词与语义绑定），就可以区分入口函数对应到顶点程序还是片段程序。
        而内部函数则忽略任何应用到形参上的语义，通常也没有人会在内部函数使用语
        义词，除非他 \ 她的目的是练习打字速度。

        下面代码展示了一个顶点程序的入口函数，名称为C2E1v_Output，这个顶点着色程序只接收二维顶点数据，然后转换为齐次坐标，并将顶点设置成绿色，最后用return语句输出

        struct C2E1v_Output {
          float4 position : POSITION;
          float3 color    : COLOR;
        };

        C2E1v_Output C2E1v_green(float2 position : POSITION)
        {   
          C2E1v_Output OUT;

          OUT.position = float4(position,0,1);
          OUT.color = float3(0,1,0);

          return OUT;   
        }
    }
    8.4 CG标准函数库
    {
        和C的标准库函数一样，CG提供了一系列内建的标准函数。这些函数用于执行数学上的通用计算或通用算法（纹理映射等），例如，需要求取入射光线和反射光线方向向量可以使用标准函数库中的reflect函数，求取入射光线方向向量可以使用refract函数，做矩阵乘法运算是可以使用mul函数

        有些函数直接和GPU指令相对应，所以执行效率非常高。绝大部分标准函数都被重载过，用于支持不同长度的数组和向量作为输入参数。

        CG标准函数会随着未来GPU硬件的发展而不断优化，所以基于标准函数库写的程序是可以用在以后的GPU硬件上的。
    }
        8.4.1 数学函数（Mathematical Functions）
        {
            这些数学函数用于执行数学上常用计算，包括:三角函数、幂函数、园函数、向量和矩阵的操作函数
            这些函数都被重载，以支持标量数据和不同长度的向量作为输入参数。


            abs(x)：  返回输入参数的绝对值
            acos(x)： 反余切函数，输入参数范围为 [-1,1] ，返回 [0, π]区间的角度值
            all(x)：  如果输入参数均不为 0 ，则返回 ture ；否则返回 flase 。 && 运算
            any(x)：  输入参数只要有其中一个不为 0 ，则返回true 。 || 运算
            asin(x)： 反正弦函数 , 输入参数取值区间为 [-1,1]，返回角度值范围为[-π/2,π/2]
            atan(x)： 反正切函数，返回角度值范围为 [-π/2,π/2]
            atan2(y,x)：计算 y/x 的反正切值。实际上和 atan(x) 函数功能完全一样，至少输入参数不同。
                        atan(x) = atan2(x, float(1)) 。
            ceil(x)：  对输入参数向上取整。例如: ceil(float(1.3)) ，其返回值为 2.0
            clamp(x,a,b)：  如果 x 值小于 a ，则返回 a ；如果 x 值大于 b ，返回 b ；否则，返回 x 。
            cos(x)：  返回弧度 x 的余弦值。返回值范围为 [-1,1] 
            cosh(x)：  双曲余弦（ hyperbolic cosine ）函数，计算 x的双曲余弦值。
            cross(A,B)：  返回两个三元向量的叉积 (cross product) 。注意，输入参数必须是三元向量！
            degrees(x)：  输入参数为弧度值 (radians) ，函数将其转换为角度值 (degrees)
            determinant(m)：  计算矩阵的行列式因子。
            dot(A,B)：  返回 A 和 B 的点积 (dot product) 。
                    参数 A 和 B可以是标量，也可以是向量（输入参数方面，点积和叉积函数有很大不同）。
            exp(x)：计算e的x次方的值， e= 2.71828182845904523536
            exp2(x)：计算 2的x次方的值
            floor(x)：  对输入参数向下取整。例如 floor(float(1.3))返回的值为 1.0 ；
                    但是 floor(float(-1.3)) 返回的值为 -2.0 。该函数与 ceil(x) 函数相对应。
            fmod(x,y)：  返回 x/y 的余数。如果 y 为 0 ，结果不可预料。
            frac(x)：返回标量的小数部分或者每个矢量的分量
            frexp(x, outexp)：将浮点数 x 分解为尾数和指数，即x = m* 2^exp ，返回 m ，
                并将指数存入 exp 中；如果 x 为 0 ，则尾数和指数都返回 0
            isfinite(x)：  判断标量或者向量中的每个数据是否是有限数，如果是返回 true ；
                否则返回 false; 无限的或者非数据 (not-a-number NaN) ，
            isinf(x)：判断标量或者向量中的每个数据是否是无限，如果是返回 true ；否则返回 false;
            isnan(x)：  判断标量或者向量中的每个数据是否是非数据 (not-a-number NaN) ，
                如果是返回 true ；否则返回 false;
            ldexp(x, n)：计算 x*2^n 的值
            lerp(a, b, f)：计算 (1-f)*a + b*f 或者 a+f*(b-a) 的值，
                即在下限 a 和上限 b 之间进行插值， f 表示权值。
                注意，如果 a 和 b 是向量，则权值 f必须是标量或者等长的向量。
            lit(NdotL,NdotH, m)：
                N 表示法向量； L 表示入射光向量； H 表示半角向量； m 表示高光系数。
                函数计算环境光、散射光、镜面光的贡献，返回的 4 元向量:
                X 位表示环境光的贡献，总是 1.0 ；
                Y 位代表散射光的贡献，如果 N dot L < 0，则为 0 ；否则为 N dot L
                Z 位代表镜面光的贡献，如果 N dot L < 0 或者 N dot H < 0则为 0 ；否则为(N dot H)^m; 
                W 位始终位 1.0
            log(x)：计算 ln (x) 的值， x 必须大于 0
            log2(x)：log以2为底的x的值，x 必须大于 0
            log10(x)：log以10为底的x的值，x 必须大于 0
            max(a, b)：比较两个标量或等长向量元素，返回最大值。
            min(a,b)：比较两个标量或等长向量元素，返回最小值。
            modf(x, out ip)：把x分离成整数和小数部分，把x的整数值存在输出参数ip处，并返回x的小数部分
            mul(M, N)：计算两个矩阵相乘，如果 M 为 AxB 阶矩阵，N 为 BxC 阶矩阵，
                则返回 AxC阶矩阵。下面两个函数为其重载函数。
                mul(M, v)：  计算矩阵和向量相乘
                mul(v, M)：  计算向量和矩阵相乘
            noise( x)：  噪声函数，返回值始终在 0,1之间；对于同样的输入，始终返回相同的值（也就是说，并不是真正意义上的随机噪声）。
            pow(x, y)： x^y

            radians(x)：  函数将角度值转换为弧度值
            round(x)：  Round-to-nearest ，或 closest integer to x 即四舍五入。
            rsqrt(x)：  X 的反平方根， x 必须大于 0
            saturate(x)：  如果 x 小于 0 ，返回 0 ；如果 x 大于 1 ，返回1 ；否则，返回 x
            sign(x)：  如果 x 大于 0 ，返回 1 ；如果 x 小于 0 ，返回-1 ；否则返回 0 。
            sin(x)：  输入参数为弧度，计算正弦值，返回值范围为 [-1,1] 
            sincos(float x,out s, out c)：
            该函数是同时计算 x 的 sin 值和 cos 值，其中s=sin(x) ， c=cos(x) 。该函数用于“同时需要计算 sin 值和 cos 值的情况”，比分别运算要快很多 !
            sinh(x)：  计算双曲正弦（ hyperbolic sine ）值。
            smoothstep(min,max, x)：x是一个[min, max]范围内的数
                如果x=min返回0，如果x=max返回1，否则返回以下公式的值
                -2*(((x-min)/(max-min))^3) + 3*(((x-min)/(max-min))^2)

            step(a, x)：如果 x<a ，返回 0 ；否则，返回 1 。
            sqrt(x)：求 x 的平方根， x ， x 必须大于 0 。
            tan(x)：  输入参数为弧度，计算正切值
            tanh(x)：  计算双曲正切值
            transpose(M)：  M 为矩阵，计算其转置矩阵

        }
        8.4.2 几何函数（Geometric Functions）
        {
            Cg 语言标准函数库中有3 个几何函数会经常被使用到，分别是:normalize函数，对向量进行归一化； reflect函数，计算反射光方向向量； refract函数，计算折射光方向向量。

            1. 着色程序中的向量最好进行归一化之后再使用，否则会出现难以预料的错误；
            2. reflect 函数和 refract 函数都存在以“入射光方向向量”作为输入参数，注意这两个函数中使用的入射光方向向量，是从外指向几何顶点的；平时我们在着色程序中或者在课本上都是将入射光方向向量作为从顶点出发。

            distance( pt1, pt2) ：两点之间的欧几里德距离（ Euclidean distance ）
            faceforward(N,I,Ng)：如果 Ng  • I< 0 ，返回 N ；否则返回 -N 。
            length(v)：  返回一个向量的模，即 sqrt(dot(v,v))
            normalize( v)：  归一化向量
            reflect(I, N)： 根据入射光方向向量 I ，和顶点法向量N ，计算反射光方向向量。其中 I 和 N必须被归一化，
                需要非常注意的是，这个 I 是指向顶点的；函数只对三元向量有效。
            refract(I,N,eta)：  计算折射向量， I 为入射光线， N 为法向量， eta 为折射系数；其中 I 和 N 必须被归一化，如果 I 和 N 之间的夹角太大，则返回（ 0 ， 0 ， 0 ），也就是没有折射光线； I 是指向顶点的；函数只对三元向量有效。
        }
        8.4.3 纹理映射函数（Texture Map Functions）
        {
            这些函数被 ps_2_0 、 ps_2_x 、arbfp1 、 fp30 和 fp40  等 profiles 完全支持（ fully supported ）。所有的这些函数返回四元向量值。

            tex1D(sampler1D tex, float s)：一维纹理查询
            tex1D(sampler1D tex, float s, float dsdx, float dsdy)：使用导数值（ derivatives ）查询一维纹理
            Tex1D(sampler1D tex, float2 sz)：一维纹理查询，并进行深度值比较
            Tex1D(sampler1D tex, float2 sz, float dsdx,float dsdy)：使用导数值（ derivatives ）查询一维纹理， 并进行深度值比较
            Tex1Dproj(sampler1D tex, float2 sq)：一维投影纹理查询
            Tex1Dproj(sampler1D tex, float3 szq)：一维投影纹理查询，并比较深度值

            Tex2D(sampler2D tex, float2 s)：二维纹理查询
            Tex2D(sampler2D tex, float2 s, float2 dsdx, float2 dsdy)：使用导数值（ derivatives ）查询二维纹理
            Tex2D(sampler2D tex, float3 sz)：二维纹理查询，并进行深度值比较
            Tex2D(sampler2D tex, float3 sz, float2 dsdx,float2 dsdy)：使用导数值（ derivatives ）查询二维纹理，并进行深度值比较
            Tex2Dproj(sampler2D tex, float3 sq)：二维投影纹理查询
            Tex2Dproj(sampler2D tex, float4 szq)：二维投影纹理查询，并进行深度值比较

            texRECT(samplerRECT tex, float2 s)   
            texRECT (samplerRECT tex, float2 s, float2 dsdx, float2 dsdy)   
            texRECT (samplerRECT tex, float3 sz) 
            texRECT (samplerRECT tex, float3 sz, float2 dsdx,float2 dsdy)
            texRECT proj(samplerRECT tex, float3 sq) 
            texRECT proj(samplerRECT tex, float3 szq) 

            Tex3d(sampler3D tex, float s)：三维纹理查询 
            Tex3D(sampler3D tex, float3 s, float3 dsdx, float3 dsdy)：结合导数值（derivatives）查询三维纹理 
            Tex3Dproj(sampler3D tex, float4 szq)： 查询三维投影纹理，并进行深度值比较 
            texCUBE(samplerCUBE tex, float3 s)：查询立方体纹理 
            texCUBE (samplerCUBE tex, float3 s, float3 dsdx, float3 dsdy)：结合导数值（derivatives）查询立方体纹理 
            texCUBEproj (samplerCUBE tex, float4 sq)：查询投影立方体纹理

                s 象征一元、二元、三元纹理坐标； z 代表使用 “ 深度比较（ depth comparison ） ”
            的值； q 表示一个透视值（ perspective value, 其实就是透视投影后所得到的齐次坐
            标的最后一位），这个值被用来除以纹理坐标（ S ），得到新的纹理坐标（已归一
            化到 0 和 1 之间）然后用于纹理查询。

                纹理函数非常多，总的来说，按照纹理维数进行分类，即： 1D 纹理函数，
            2D 纹理函数， 3D 纹理函数，已经立方体纹理。需要注意， TexREC 函数查询的
            纹理实际上也是二维纹理。

            3D 纹理，另一个比较学术化的名称是 “ 体纹理（ Volume Texture ） ” ，体纹理通常用于体绘制，体纹理用于记录空间中的体细节数据。

                通常的二维纹理记录每个三角面皮上的颜色信息，但并不会记录体内的信息，体纹理
            记录三个方向，从里到外的信息，

            还有一类较为特殊的纹理查询函数以 proj 结尾，主要是针对投影纹理进行查询。
            所谓投影纹理是指：将纹理当做一张幻灯片投影到场景中，使用投影纹理技术需要计算投影纹理坐标，然后使用投影纹理坐标进行查询。使用投影纹理坐标进行查询的函数就是投影纹理查询函数。

                本质来说，投影纹理查询函数和普通的纹理查询函数没有什么不同，唯一的
            区别在于 “ 投影纹理查询函数使用计算得到的投影纹理坐标，并在使用之前会将
            该投影纹理坐标除以透视值 ” 。

            使用二维投影纹理查询函数：
                tex2Dproj(texture,uvproj);
            等价于按如下方法使用普通二维纹理查询函数：
                float4 uvproj = uvproj/uvproj.q;
                tex2D(texture,uvproj);

        }
        8.4.4 偏导函数（Dericative Functions）
        {
            ddx(a)： 参数 a 对应一个像素位置，返回该像素值在 X 轴上的偏导数
            ddy(a)： 参数 a 对应一个像素位置，返回该像素值在 Y 轴上的偏导数

            如果函数 ddx 的参数为 myVar ，该参数对应的像素点
            记为  p(i,j) ，则 ddx(myVar) 的值为 “ 像素点 p(i+1,j)的值减去 myVar” 。
            同理，ddy(myVar) 的值为 “ 像素点 ( ) , p(i,j+1) 的值减去 myVar” 。如果函数 ddx 和 ddy 的输入参数为常数，则函数返回值永远为 0 。

            这里面存在像素点所对应数据的类型问题。从前面的知识可知，传入片段程
            序的顶点属性一般有：屏幕坐标空间的顶点齐次坐标、纹理坐标、法向量、光照
            颜色等。假设传递给 ddx\ddy 函数的参数 myVar 是纹理坐标，则， ddx(myVar)
            的值为，纹理上像素点 ( ) 1, p i j + 的纹理颜色值减去 myVar 对应的纹理颜色值。

            1. 函数 ddx 和 ddy 用于求取相邻像素间某属性的差值；
            2. 函数 ddx 和 ddy 的输入参数通常是纹理坐标；
            3. 函数 ddx 和 ddy 返回相邻像素键的属性差值；

            现代的 GPU 中提供了计算 partial derivative 的指令（通常被称
            为梯度指令或者偏导数指令， DDX 或 DDY ）， Cg 中所对应的函数为 ddx() 和
            ddy()( 注： glsl 和 hlsl 中也有该函数 ) 。按照屏幕相关空间 x 或 y 计算偏导数，对
            纹理滤镜以及抗锯齿等非常有用（注：也可以用于 TXD 纹理查找的参数计算）。

            学过高等数学应该知道，偏导数的物理含义是：在某一个方向上的变化快慢。
            所以 ddx 求的是 X 方向上，相邻两个像素的某属性值的变化量； ddy 球的是 Y
            方向上，相邻两个像素的某属性值的变化量。

            正是由于 ddx 和 ddy 指令是作用于像素级的，所以 ddx 和 ddy 函数只被片段程序所支持。

            当在纹理查询函数中使用 ddx 和 ddy 是可以进行图形过滤。所谓图像过滤，
            一个比较简单的定义是：对于给定的输入图像 A ，要创建新的图像 B ，把源图像
            A 变换到目标图像 B 的操作就是图像滤波。最一般的变换是调整图像大小、锐
            化、变化颜色，以及模糊图像等。复杂的过滤有赖于知道究竟需要过滤多少纹理。
            象 GeForce 那样的现代 GPU 提供的偏导函数可以帮助我们
        }
        8.4.5 调试函数（Debugging Functions）
        {
            void debug(float4 x)
            如果在编译时设置了 DEBUG ，片段着色程序中调用该函数可以将值 x 作为COLOR 语义的最终输出；否则该函数什么也不做。

            首先顶点 profiles 不支持调试函数。总的来说，目前所有的 shader language中的调试功能都非常有限，表 8 中列出的 debug 函数实际上十分鸡肋，能起到的作用非常有限的，随着而来的影响是 “ 难以查找程序逻辑错误 ” 。目前对 Cg 程序无法像 C++ 程序一样进行运行调试，步步跟踪。
        }
    8.5 在未来将被解决的问题
    {
        首先，我们希望着色语言可以做到方便进行通用计算编程，而不被数据之间的独立性所限制；
        其次，我们希望着色语言可以在控制语句方面有所加强；
        此外，着色语言还需要引入继承机制，让其面向对象的特征更加明显；
        要加强调试功能，可以对程序执行过程进行调试（现阶段好像比较困难），如果没有很好的调试功能，也希望可以有一个比较通用的IDE 提供给编程者；
        未来的可编程图形硬件的顶点处理器要能进行纹理信息的查询；
        我们还希望越来越的领域可以被 GPU 编程所介入，而不会因为其学习的难度被限制。
    }
    开篇语：
    {
        针对光照模型和阴影算法的相关知识点进行讲解，这些算法都用于面绘制，即计算物体表面某点的颜色值；

            面绘制和体绘制的区别从字面意思上就可以理解一二，体绘制专注于表现物体内部结构，例如一个房子
        模型，使用面绘制算法，可以让用户观察到房子的外部特征，而使用体绘制算法，则可以让用户观察到墙体中的电缆水管。不过，光照算法、阴影算法等也可以用于体绘制，加强真实感。

        光照模型（ illumination model ），也称为明暗模型，用于计算物体某点处的光强（颜色值）。
        从算法理论基础而言，光照模型分为两类：一种是基于物理理论的，另一种是基于经验模型的。

        基于物理理论的光照模型，偏重于使用物理的度量和统计方法，比较典型的有 ward BRDF 模型，其中的不少参数是需要仪器测量的，使用这种光照模型的好处是 “ 效果非常真实 ” ，但是 “ 计算复杂，实现起来也较为困难 ” ；

        经验模型更加偏重于使用特定的概率公式，使之与一组表面类型相匹配，所以经验模型大都比较简洁，效果偏向理想化。

            其实两者之间的界限并不是明确到 “ 非黑即白 ” 的地步，
        无论何种光照模型本质上还是基于物理的，只不过在求证方法上各有偏重而已。

        从使用角度而言，光照模型分为局部光照模型和全局光照模型。所谓局部光照模型，是将光照的种类进行分解，在计算时只考虑其中的一种；而全局光照模型则是考虑到所有的光照种类。

        一个比较类似的例子是物理力学，牛顿力学最初是考虑理想状态下的运动方式，无摩擦力；然后慢慢的会在力的条件中考虑到摩擦力因素；接着会学习弹性系数。

        总之是一个原本复杂的过程分解为各种子过程，然后渐进叠加

        光照模型的英文缩写IM
    }
9、经典光照模型（illumination model）
{
    当光照射到物体表面的时候，一部分被物体表面吸收，另一部分被反射，对于透明物体而言，还有一部分光穿过透明体，产生折射光。被物体吸收的光能转化为热量，只有反射光和透射光能够进入眼睛，产生视觉效果。通过反射和透射产生的光波（光具有波粒二相性）决定了物体呈现的亮度和颜色，即反射和投射光的强度决定了物体表面的亮度，而它们含有的不同波长光的比例决定了物体表面的色彩。

    所以，物体表面光照颜色由入射光、物体材质，以及材质和光的交互规律共同决定。

    光与物体最基本的交互方式就是反射，遵循反射定律：
    反射光与入射光位于表面法向两侧，对理想反射面（如镜面），入射角等于反射角，观察者只能在表面法向的反射方向一侧才能看到反射光。 
    不过世界上并不存在真正的理想反射体，正如物理学中绝对的匀速状态是不存在的。
}
    9.1 光源
    {
        环境光（Ambient Light）:从物体表面所产生的反射光的统一照明，称为环境光或背景光。

        例如房间里面并没有受到灯光或者太阳光的直接照射，而是由墙壁、天花板、地板及室内各物体之间光的多次反射进行自然照明。

        通常我们认为理想的环境光具有如下特性：
        没有空间或方向性；在所有方向上和所有物体表面上投射的环境光强度是统一的恒定值。

        环境光是对光照现象的最简单抽象，局限性很大。它仅能描述光线在空间中无方向并均匀散布时的状态。
        真实的情况是：光线通常都有方向。
        点光源是发光体的最简单的模型，光线由光源出发向四周发散。
        还有一种是平行光，即光线都从同一个方向照射。
        通过模拟方向光和物体表面的交互模式，可以渲染出具有高真实感（明暗变化、镜面反射等）的三维场景。
    }
    9.2 漫反射与Lambert模型
    {
        粗糙的物体表面向各个方向等强度地反射光，这种等同地向各个方向散射的现象称为光的漫反射（ diffuse reflection ）。
        产生光的漫反射现象的物体表面称为理想漫反射体，也称为朗伯（ Lambert ）反射体。

        对于仅暴露在环境光下的朗伯反射体，可以用下面公式表示某点处漫反射的光强：
        I = k*i
        其中i 表示环境光强度（简称光强），k(0<k<1)为材质对环境光的反射系数，I 是漫反射体与环境光交互反射的光强。

        即使一个理想的漫反射体在所有方向上具有等量的反射光线，但是表面光强还依赖于光线的入射方向（方向光）。例如，入射光方向垂直的表面与入射光方向成斜角的表面相比，其光强要大的多。这种现象可以用 Lambert 定律进行数学上的量化。

        即，当方向光照射到朗伯反射体上时，漫反射光的光强与入射光的方向和入射点表面法向夹角的余弦成正比，这称之为 Lambert 定律，并由此构造出 Lambert漫反射模型：

        Il = k*I1*cos(a);
        
        I1 是点光源强度， a 是入射光方向与顶点法线的夹角，称为入射(0≤ θ ≤90°)，Il 是漫反射体与方向光交互反射的光强。入射角为零时，说明光线垂直于物体表面，漫反射光强最大；90°时光线与物体表面平行，物体接收不到任何光线。

        若 N 为顶点单位法向量， L 表示从顶点指向光源的单位向量
        [注意，是由顶点指向光源，不要弄反了]，则 cos a 等价于 N 与 L 的点积。

        Il = k*I1*(N dot L)

        综合考虑环境光和方向来，Lambert 光照模型可写为：
        Id = I + Il = k*i + k*I1(N dot L)


    }
        9.2.1 漫反射渲染
        {
            代码1：漫反射光照模型顶点着色程序

            void main_v(float4 position :POSITION,
                float4 normal   :NORMAL,

                out float4 oPosition    :POSITION,
                out float4 color        :COLOR,

                uniform float4x4 modelViewProj,
                uniform float4x4 worldMatrix,
                uniform float4x4 worldMatrix_IT,
                uniform float3 globalAmbient,
                uniform float3 lightPosition,
                uniform float3 lightColor,
                uniform float3 Kd
                )
            {
                oPosition = mul(modelViewProj,position);
                float3 worldPos = mul(worldMatrix,position).xyz;
                float3 N = mul(worldMatrix_IT,normal).xyz;
                N = normalize(N);

                //计算入射光方向
                float3 L = lightPosition - worldPos;
                L = normalize(L);

                //计算方向光漫反射光强
                float3 diffuseColor = Kd * lightColor * max(dot(N,L),0);

                //计算环境光漫反射光强
                float3 ambientColor = Kd * globalAmbient;

                color.rgb = diffuseColor + ambientColor;
                color.a = 1;
            }

            代码2：漫反射光照模型顶点着色程序（使用结构体）

            struct VertexIn
            {
                float4 position:POSITION;
                float4 normal:NORMAL;
            };

            struct VertexScreen
            {
                float4 oPosition:POSITION;
                float4 color:COLOR;
            };

            void main_v(VertexIn posIn,out VertexScreen posOut,
                        uniform float4x4 modelViewProj,
                        uniform float4x4 worldMatrix,
                        uniform float4x4 worldMatrix_IT,
                        uniform float3 globalAmbient,
                        uniform float3 lightPosition,
                        uniform float3 lightColor,
                        uniform float3 Kd)
            {
                posOut.oPosition = mul(modelViewProj,posIn.position);

                float3 worldPos = mul(worldMatrix,posIn.position).xyz;
                N = normalize(N);

                //计算入射光方向
                float3 L = lightPosition - worldPos;
                L = normalize(L);

                //计算方向光漫反射光强
                float3 diffuseColor = Kd * lightColor * max(dot(N,L),0);

                //计算环境光漫反射光强
                float3 ambientColor = kd * globalAmbient;

                posOut.color.rgb = diffuseColor + ambientColor;
                posOut.color.a = 1;
            }


            在着色程序中使用结构体会使得代码易编写、易维护。
        }
    9.3 镜面反射与Phong模型
    {
            Lambert 模型较好地表现了粗糙表面上的光照现象，如石灰粉刷的墙壁、纸
        张等，但在用于诸如金属材质制成的物体时，则会显得呆板，表现不出光泽，主
        要原因是该模型没有考虑这些表面的镜面反射效果。

            一个光滑物体被光照射时，可以在某个方向上看到很强的反射光，这是因为在接近镜面反射角的一个区域
        内，反射了入射光的全部或绝大部分光强，该现象称为镜面反射。

            故此， Phong Bui Tuong 提出一个计算镜面反射光强的经验模型，称为 phong
        模型，认为镜面反射的光强与反射光线和视线的夹角相关。

            Is = Ks * Il * (V dot R)^ns 

            Ks 为材质的镜面反射系数，ns是高光指数，V表示从顶点到视点的观察方向，R表示反射光方向。
            高光指数反映了物体表面的光泽程度。ns越大，反射光越集中，当偏离反射方向时，光线衰减得越厉害，只有当
        视线方向与反射光线方向非常接近时才能看到镜面反射的高光现象，此时，镜面反射光将会在反射方向附近形成亮且小的光斑；ns越小，表示物体月粗糙，反射光分散，观察到的光斑区域小，强度弱。
            反射光的方向R可以通过入射光方向L（从顶点指向光源）和物体法向量N 求出:
            R + L = 2 * (N dot L)* N
            R  = 2 * (N dot L)* N - L


    }
        9.3.1 Phong模型渲染
        {
            为了使得低精度模型也能得到高质量的渲染效果，就必须进行片段渲染，所
        以本节中我们还将给出使用片段着色程序的 phong 光照模型渲染代码和效果。

            代码 3 phong 光照模型的顶点着色程序实现
            struct VertexIn
            {
                float4 position:POSITION;   //Vertex in object - space
                float4 normal:NORMAL;
            };
            struct VertexScreen
            {
                float4 oPosition:POSITION;
                float4 color:COLOR;
            };
            void main_v(VertexIn posIn,
                        out VertexScreen posOut,
                        uniform float4x4 modelViewProj,
                        uniform float4x4 worldMatrix,
                        uniform float4x4 worldMatrix_IT,
                        uniform float3 globalAmbient,
                        uniform float3 eyePosition,
                        uniform float3 lightPosition,
                        uniform float3 lightColor,
                        uniform float3 Kd,
                        uniform float3 Ks,
                        uniform float shininess
                        )
            {
                posOut.oPosition = mul(modelViewProj,posIn.position);

                float3 worldPos = mul(worldMatrix,posIn.position).xyz;
                float3 N = mul(worldMatrix_IT,posIn.normal).xyz;
                N = normalize(N);

                //计算入射光方向、视线方向、反射光线方向
                float3 L = normalize(lightPosition - worldPos);
                float3 V = normalize(eyePosition - worldPos);
                float3 R = 2 * max(dot(N,L),0) * N - L;
                R = normalize(R);

                //计算漫反射分量
                float3 diffuseColor = Kd * globalAmbient + Kd * lightColor * max(dot(N,L),0);
                //计算镜面反射分量
                float3 specularColor = Ks * lightColor * pow(max(dot(V,R),0),shininess);

                posOut.color.rgb = diffuseColor + specularColor;
                posOut.color.a = 1;
            }

                下面给出同时使用顶点着色程序和片段着色程序的 phong 光照模型代码。依
            然是首先定义结构体，用来包含输入、输出数据流，不过这里使用的结构体（代
            码 4 ）和代码 3 中的有所不同，在 VertexScreen 结构体中有两个绑定到
            TEXCOORD 语义词的变量， objectPos 和 objectNormal ，这两个变量用于传递顶
            点模型空间坐标和法向量坐标到片段着色器中。

            代码 4 phong 光照模型片段着色实现的结构体
            struct VertexIn
            {
                float4 position : POSITION;
                float4 normal : NORMAL;
            };

            struct VertexScreen
            {
                float4 oPosition : POSITION;
                float4 objectPos : TEXCOORD0;
                float4 objectNormal : TEXCOORD1;
            };

            代码 5 phong 光照模型顶点着色程序

            void main_v(VertexIn posIn,out VertexScreen posOut,
                        uniform float4x4 modelViewProj)
            {
                posOut.oPosition = mul(modelViewProj,posIn.position);
                posOut.objectPos = posIn.position;
                posOut.objectNormal = posIn.normal;
            }

                代码 6 展示了使用 phong 光照模型渲染的片段着色程序。我将反射光方向、
            视线方向、入射光方向都放在片段着色程序中计算，实际上这些光照信息也可以
            放到顶点着色程序中计算，然后传递到片段着色程序中。

            代码 6 phong 光照模型片段着色程序

            void main_f(VertexScreen posIn,
                        out float4 color : COLOR,
                        uniform float4x4 worldMatrix,
                        uniform float4x4 worldMatrix_IT,
                        uniform float3 globalAmbient,
                        uniform float3 eyePosition,
                        uniform float3 lightPosition,
                        uniform float3 lightColor,
                        uniform float3 Kd,
                        uniform float3 Ks,
                        uniform float shininess
                        )
            {
                float3 worldPos = mul(worldMatrix,posIn.objectPos).xyz;
                float3 N = mul(worldMatrix_IT,posIn.objectNormal).xyz;
                N = normalize(N);

                //计算入射光方向、视线方向、反射光线方向
                float3 L = normalize(lightPosition - worldPos);
                float3 V = normalize(eyePosition - worldPos);
                float3 R = 2 * max(dot(N,L),0) * N - L;
                R = normalize(R);

                //计算漫反射分量
                float3 diffuseColor = Kd * globalAmbient + Kd * lightColor * max(dot(N,L),0);

                //计算镜面反射分量
                float3 specularColor = Ks * lightColor * pow(max(dot(V,R),0),shiness);

                colro.rgb = diffuseColor + specularColor;
                color.a = 1;
            }
        }
    
    9.4 Blinn-Phong光照模型
    {
        Blinn-Phong 光照模型，又称为 Blinn-phong 反射模型( Blinn–Phong reflection model)
        、phong 修正模型（ modified Phong reflection model ）

        是由 Jim Blinn于 1977 年在文章 “Models of light reflection for computer synthesized pictures” 中对传统 phong 光照模型基础上进行修改提出的

            和传统 phong 光照模型相比，Blinn-phong 光照模型混合了 Lambert 的漫射部分和标准的高光，渲染效果有时
        比 Phong  高光更柔和、更平滑，此外它在速度上相当快，因此成为许多 CG 软件中的默认光照渲染方法。
        此外它也集成在了大多数图形芯片中，用以产生实时快速的渲染。
        在 OpenGL 和 Direct3D 渲染管线中， Blinn-Phong 就是默认的渲染模型。

        phong 光照模型中，必须计算 V•R 的值，其中 R 为反射光线方向单位向量，
        V 为视线方向单位向量，但是在 Blinn-phong 光照模型中，用 N • H 的值取代了V•R。
        
        Blinn - phong光照模型公式为:

        Is = Ks* Il * (N • H)^ns

        其中 N 是入射点的单位法向量， H 是“光入射方向 L 和视点方向 V 的中间向量”，通常也称之为半角向量.
        注意：半角向量被广泛用于各类光照模型，
        原因不但在于半角向量蕴含的信息价值，也在于计算半角向量是一件简单、耗时不多的工作。
        H = (L + V) / | L + V |

        通常情况下，使用 Blinn-phong 光照模型渲染的效果和 phong 模型渲染的效果没有太大的区别，有些艺术工作者认为 phong 光照模型比 blinn-phong 更加真实，实际上也是如此。

          Blinn-phong 渲染效果要更加柔和一些， Blinn-phong 光照
        模型省去了计算反射光线方向向量的两个乘法运算，速度更快。由于 Blinn-phong
        和 phong 模型的唯一区别一个使用半角向量，一个使用反射光方向向量，所以下
        面只给出 Blinn-phong 模型的片段着色程序代码。

        代码 7 Blinn-phong 模型片段着色程序
        void main_f(VertexScreen posIn,
                    out float4 color : COLOR,
                    uniform float4x4 worldMatrix,
                    uniform float4x4 worldMatrix_IT,
                    uniform float3 globalAmbient,
                    uniform float3 eyePosition,
                    uniform float3 lightPosition,
                    uniform float3 lightColor,
                    uniform float3 Kd,
                    uniform float3 Ks,
                    uniform float shininess)
        {
            float3 worldPos = mul(worldMatrix, posIn.objectPos).xyz;
            float3 N = mul(worldMatrix_IT, posIn.objectNormal).xyz;
            N = normalize(N);

            //计算入射光方向\视线方向\半角向量
            float3 L = normalize(lightPosition - worldPos);
            float3 V = normalize(eyePosition - worldPos);
            float3 H = normalize(L + V);

            // 计算漫反射分量
            float3 diffuseColor = Kd * globalAmbient+Kd*lightColor*max(dot(N, L), 0);

            //计算镜面反射分量
            float3 specularColor = Ks * lightColor*pow(max(dot(N, H), 0), shininess);
            color.RGB = diffuseColor + specularColor;
            color.a = 1;
        }

         phong 光照模型确实要比 blinn-phong渲染效果要真实。与 phong 光照模型相比，使用 blinn-phong 进行光照渲染，在同样的高光系数下，高光领域覆盖范围较大，明暗界限不明显.
    }
    9.5 全局光照模型与RenderingEquation
    {
        Kajia 在 1986 年提出 rendering equation（渲染方程）
        双向反射分布函数（Bidirectional Reflectance Distribution Function，BRDF）用来定义给定入射方向上的辐射照度（irradiance）如何影响给定出射方向上的辐射率（radiance）。更笼统地说，它描述了入射光线经过某个表面反射后如何在各个出射方向上分布——这可以是从理想镜面反射到漫反射、各向同性（isotropic）或者各向异性（anisotropic）的各种反射。
    }
    9.6 本章小结
    {
        这一章主要对比较经典的光照模型进行了论述，这些光照模型虽然简单，却
        是目前所有光照算法和图形硬件光照处理的基础。正是由于前辈们做出的贡献，
        才有了今天疯狂玩魔兽的庞大人群。虽然目前光线跟踪算法和辐射度算法已经在
        GPU 上得到了实现，但本章并没有对光线跟踪算法和辐射度算法做出论述，主
        要是因为考虑到技术的复杂度，我打算将其放到本书的下一版再进行阐述。
    }
10、高级光照模型
{
        在过去的一段时间中，光照模型得到了深入的发展，人们不再满足于只是对
    漫反射现象和镜面反射现象进行模拟，而是希望可以模拟更多特殊材质上的光照
    效果，如同向异性、各项异性等。

    上一章已经提到过，无论是漫反射，还是镜面
    反射，都属于材质和光交互的理想状态，就好像物理学中的无阻力状态和恒温状
    态，真实的情况是:漫反射和镜面反射都需要依据材质特征和物体表面微平面特
    征。

        材质和光的交互方式是多种多样的，例如，我们可以在光盘上看到如扇面般
    的光带分布，在光滑的圆柱形炊具上可以看到光的条纹。为了衡量材质的光学特
    征和物体表面微平面特征， BRDF （ Bidirectional Reflectance Distribution Function ）
    模型应运而生。

        本章将要讲到的以 BRDF 模型为代表的一些新的光照模型，它们的共同特点
    是，扩展了材质和光的交互方式，充分考虑材质微平面对光的影响。

     Cook-Torrance 光照模型
      BRDF 表示双向反射分布函数（ Bidirectional Reflectance Distribution
    Function ），用来描述光线如何在物体表面进行反射。

    BRDF 模型的概念较为复杂，
    其中亦有许多不同的分枝模型，中文资料中少有对该类型模型给出详细讲解和实
    现代码的，不过该领域的研究已经是国际上一个热点，确有学习和研究的价值。
}
    10.1 Cook-Torrance 光照模型
    {
        使用 phong 和 blinn-phong 光照模型渲染出来的效果都存在一个问题:效果
        过于艺术化，不太真实。这是因为这两种模型都对材质细节方面没有进行考虑。

        1981 年， Robert L. Cook 和 Kenneth E. Torrance 发表了名为 “A Reflectance
        Model For Computer Graphics” 的论文，首次提出了 Cook-Torrance 光照模型。

        Cook-Torrance 光照模型将物体粗糙表面（ rough surface ）看作由很多微小平
        面（微平面）组成，每一个微平面都被看作一个理想的镜面反射体，物体表面的
        粗糙度由微平面斜率的变化来衡量。一个粗糙表面由一系列斜率变化很大的微平
        面组成，而在相对平滑的表面上微平面斜率变化较小。

        Cook-Torrance 模型将光分为两个方面考虑:漫反射光强和镜面反射光强。

        I(c-t) = I(diff) + I(spec) = I(diff) + Ks*Il*Rs

        I(diff)是漫反射光强,Ks*Il*Rs是镜面反射光强的计算方法
         cook-Torrance 模型与 phong 、blinn-phong 模型的不同之处在于Rs的计算方法。
         实际上， cook-Torrance 、 phong和 blinn-phong 三种光照模型的本质区别都在于 “ 使用不同数学表达式计算Rs ” 。Rs在英文中称之为 “specular term” 。

         在 Wikipedia的 specular highlight 网页中提供的计算方法为公式

         Rs = (F*D*G)/(V dot N)

         在《 3D 游戏与计算机图形学中的数学方法》第 117 页和 D3DBook (Lighting) Cook-Torrance 一文中给出的数学表达均为公式

          Rs = (F*D*G)/((V dot N)*(N dot L))

          在“ A Reflectance Model For Computer Graphics ”一文中对公式的原始
            出处进行了查询，确定下面的公式是正确的数学表达

        F 是 Fresnel 反射系数（ Fresnel reflect term ），表示反射方向上的光强占原始
        光强的比率； D 表示微平面分布函数（ Beckmann distribution factor ），返回的是
        “给定方向上的微平面的分数值”； G 是几何衰减系数（ Geometric attenuation
        term ），衡量微平面自身遮蔽光强的影响。 N 、 V 、 L 分别表示法向量、视线方
        向（从顶点到视点）和入射光方向（从顶点向外）

        schlick 给出了 Fresnel 反射系数的一个近似（参阅第 11 章），精度在 1% 范围内，如下面公式所示：
        F = f0 + (1 - f0)(1-V dot H)^5
        f0为入射角度接近0（入射方向靠近法向量）时的Fresnel反射系数，V是指向视点的向量。H是半角向量。
        微平面分布函数：根据给定的半角向量 H ，微平面分布函数返回微平面的分数值。

        微平面上的入射光，在到达一个表面之前或被该表面反射之后，可能会被相
        邻的微平面阻挡，未被遮挡的光随机发散，最终形成了表面漫反射的一部分。这
        种阻挡会造成镜面反射的轻微昏暗，可以用几何衰减系数来衡量这种影响。

    }
        10.1.1 Cook-Torrance 光照模型渲染实现
        {
            顶点着色程序如下所示：
            代码 8 Cook-Torrance 光照模型顶点着色程序

            void main_v( float4 position : POSITION,
                        float4 normal : NORMAL,
                        out float4 oPosition : POSITION,
                        out float3 worldPos : TEXCOORD0,
                        out float3 oNormal : TEXCOORD1,
                        uniform float4x4 worldMatrix,
                        uniform float4x4 worldMatrix_IT,
                        uniform float4x4 worldViewProj)
            {
                oPosition = mul(worldViewProj, position);
                worldPos = mul(worldMatrix, position).xyz;
                oNormal = mul(worldMatrix_IT,normal).xyz;
                oNormal = normalize(oNormal);
            }

            片段着色程序为：
            代码 9 Cook-Torrance 光照模型片段着色程序

            void main_f(float3 position : TEXCOORD0,
                        float3 normal : TEXCOORD1,
                        out float4 color : COLOR,
                        uniform float3 globalAmbient,
                        uniform float3 lightColor,
                        uniform float3 lightPosition,
                        uniform float3 eyePosition,
                        uniform float3 Ka,
                        uniform float3 Kd,
                        uniform float3 Ks,
                        uniform float f,
                        uniform float m)
            {
                float3 P = position.xyz;
                float3 N = normalize(normal);
                float3 ambient = Ka * globalAmbient; // 计算环境光分量

                float3 L = normalize(lightPosition - P);
                float nl = max(dot(L, N), 0);
                float3 diffuse = Kd * lightColor * nl; // 计算漫反射光分量

                float3 V = normalize(eyePosition - P);
                float3 H = normalize(L + V);
                float3 specular = float3(0.0,0.0,0.0);
                float nv = dot(N,V);
                bool back = (nv>0) && (nl>0);

                if(back)
                {
                    float nh = dot(N,H);
                    float temp = (nh*nh-1)/(m*m*nh*nh);
                    float roughness = (exp(temp))/(pow(m,2)*pow(nh,4.0)); //粗糙度，根据 beckmann函数

                    float vh = dot(V,H);
                    float a = (2*nh*nv)/vh;
                    float b = (2*nh*nl)/vh;
                    float geometric = min(a,b);
                    geometric = min(1,geometric); //几何衰减系数

                    float fresnelCoe=f+(1-f)*pow(1-vh,5.0); //fresnel 反射系数

                    float rs = (fresnelCoe*geometric*roughness)/(nv*nl);
                    specular = rs * lightColor * nl*Ks; // 计算镜面反射光分量（这是重点）

                }
                color.xyz = ambient + diffuse + specular;
                color.w = 1;
            }
            阿斯顿法
        }
    10.2 BRDF光照模型
        10.2.1 什么是BRDF光照模型
        {
            1965 年， Nicodemus, Fred  在论文 “Directional reflectance and emissivity of an opaque surface”  中提出了 BRDF 的概念。
            BRDF,Bidirectional Reflectance Distribution Function,双向反射分布函数。该函数描述了入射光线在非透明物体表面如何进行反射。

            BRDF的结果是一个没有单位的数值，表示在给定入射条件下，某个出射方向上反射光的相对能量，也可以理解为
            “入射光以特定方向离开的概率”（实时计算机图形学第二版111页）
            这些信息也可以用仪器进行测试记录，并存放在图片上，称为 polynomial texture map

            从物理光学上我们可以理解为： BRDF 函数计算的是 “ 特定反射方向的光强与入射光强的比例 ” 
        }
        10.2.2 什么是各向异性
        {
            各向异性 (anisotropy) 与均向性相反，是指在不同方向具有不同行为的性质，
            也就是其行为与方向有关。如在物理学上，沿着材料做不同方向的量测，若会出
            现不同行为，通常称该材料具有某种 “ 各向异性 ” ，这样的材料表面称为各向异性
            表面（ anisotropic surface ）；
            特殊的晶体结构会导致各向异性，材质表面上存在有组织的细小凹凸槽也会
            导致各向异性。
            各向异性反射是指：各向异性表面反射光的一种现象。在生活中
            我们经常见到各向异性光照效果，例如光滑的炊具上的扇面光斑

            由于材质有组织的细微凹凸结构的不同，各向异性也分为基本的三种类型:
            1. 线性各向异性；
            2. 径向各向异性；
            3. 圆柱形各向异性，实际上线性各向异性，单被映像为圆柱形。
        }
    10.3 Bank BRDF经验模型
    {
        Bank BRDF 属于经验模型，由于其计算简单，且效果良好，所以该模型在各向异性光照效果的模拟方面非常有用。

        f = Ks * (sqrt(1-(L dot T)^2) * sqrt(1-(V dot T)^2) - (L dot T)*(V dot T))^ns

        Ks、ns分别表示镜面反射系数和高光系数；L表示入射光线方向，V表示视线观察方向、T表示该点的切向量。尤其注意切向量的计算方法，因为一个三维空间点可能存在无数个切向量，通常我采用“顶点的法向量和视线方向做叉积，其结果为T”

        代码 10 Bank BRDF 的顶点着色程序
        void main_v(float4 position : POSITION,
                    float4 normal : NORMAL,
                    out float4 oPosition : POSITION,
                    out float3 worldPos : TEXCOORD0,
                    out float3 worldNormal : TEXCOORD1,
                    uniform float4x4 modelViewProj,
                    uniform float4x4 worldMatrix,
                    uniform float4x4 worldMatrix_IT)
            {
                oPosition = mul(modelViewProj, position);
                worldPos = mul(worldMatrix, position).xyz;
                worldNormal = mul(worldMatrix_IT, normal).xyz;
            }

代码 11 Bank BRDF 片段着色程序
            void main_f(float4 position : TEXCOORD0,
                        float3 normal : TEXCOORD1,
                        out float4 color : COLOR,
                        uniform float3 globalAmbient,
                        uniform float3 lightColor,
                        uniform float3 lightPosition,
                        uniform float3 eyePosition,
                        uniform float3 Ka,
                        uniform float3 Kd,
                        uniform float3 Ks,
                        uniform float shininess)
            {
                float3 P = position.xyz;
                float3 N = normalize(normal);
                float3 ambient = Ka * globalAmbient; //计算环境光分量
                float3 L = normalize(lightPosition - P);
                float ln = max(dot(L, N), 0);
                float3 diffuse = Kd * lightColor *ln; // 计算有向光漫反射分量
                // 计算镜面反射分量
                float3 V = normalize(eyePosition - P);
                float3 H = normalize(L + V);
                float3 specular = float3(0.0,0.0,0.0);
                bool back = (dot(V,N)>0) && (dot(L,N));
                if(back)
                {
                    float3 T = normalize(cross(N,V)); //计算顶点切向量
                    float a = dot(L,T);
                    float b = dot(V,T);
                    float c = sqrt(1-pow(a,2.0))* sqrt(1-pow(b,2.0)) - a*b; //计算 Bank BRDF 系数
                    float brdf = Ks* pow(c, shininess);
                    specular = brdf * lightColor *ln;
                }
                color.xyz = ambient + diffuse + specular;
                color.w = 1;
            }
    }
    10.4 本章小结
    {
        BRDF 模型有很多分支模型，如 HTSG BRDF 模型擅长模拟很多物理现象，
    是现今最完整的 BRDF 模型，但是同时需要昂贵的计算开销； Ward BRDF 用于
    各向异性表面的经验模型有些复杂，并且需要从实际物体表面来获取 BRDF 数
    据。这些数据可以通过测角仪、图像双向反射计来得到，国外网站也有一些公开
    的数据库。
    }
11、透明光照模型与环境贴图
{
        材质和光的交互除了反射现象，对于透明物体还存在透射现象。模拟光的透
    射现象通常是一个比较头痛的问题，因为需要至少计算光的两次透射方向，首先
    计算光从介质一进入介质二的透射方向，然后计算光从介质二进入介质一的透射
    方象。此外，光在透明物体内穿越的距离以及被穿越的材质，直接关系到光的衰
    减程度；加上，还有很复杂的透明材质的次表面散射现象，即光线渗透到透明材
    质中，在内部发生散射，最后射出物体并进入视野中产生的现象。总而言之，不
    论在 CPU 上还是在 GPU 上，想要精确完善的模拟光透现象是一件相当复杂的事
    情。

        我们常听说的光线跟踪算法，虽然可以跟踪模拟出光透现象，但是对于次表
    面散射的模拟无能为力，并且基于 CPU 的光线跟踪算法是无法达到实时要求的。
    基于 GPU 的光线跟踪算法已经得到实现，不过我并不打算在本书中进行阐述，而
    是转而讲解较为基础的简单透明光照模型，以及其基于 GPU 的实现方法。待读者
    掌握了这个基础实现后，我会在本套书的第二版中再阐述基于 GPU 的复杂光透模
    拟的相关算法。

        在一个场景中，光滑的物体表面往往会映射出周围环境，想象一下，一款赛
    车游戏中，当你的车呼啸而过时，车身同时映射出周围的景色，流光飞扬。为了
    达到这样的效果，通常使用环境贴图技术。

        本章中，首先给出与光透现象相关的两个重要光学定律： Snell 定律和 Fresnel
    定律；然后阐述如何使用环境贴图方法模拟光滑表面对周围场景的映射效果，并
    给出 GPU 实现代码；最后讲解简单透明光照模型，并给出 GPU 实现代码。这些技
    术非常有用，在大家所玩的 3D 游戏中，为了在效率和效果上达到平衡，百分之
    百是采用这些技术或者这些技术的变体。
}
    11.1 Snell定律与Fresnel定律
        11.1.1 折射率与Snell定律
        {
            光在真空中的速度 c 与在透明介质中的速度 v 之比，称之为该介质的绝对折射率，简称折射率。
            光在真空中的折射率等于 1 ，通常我们认为光在空气中的折射率也近视为 1 。
            n = c/v;
            折射率较大介质的称为光密介质，折射率较小的介质称为光疏介质。
            材质             折射率值
            真空 \ 空气      1.0\ 1.0003
            水               1.333
            玻璃             1.5-1.7
            钻石             2.417
            冰               1.309

            Snell 定律描述光线从一个介质传播到另一个介质时，入射角、折射角和介质折射率的关系。
            假设光线从空气射入水面，入射角度为a1,空气对光线的折射率为n1,折射角度为a2,水对光线的折射率为n2
            则：
            sin(a1) * n1 = sin(a2) * n2; 
            通过 snell 定律，我们可以根据入射光的方向向量求取折射光的方向向量
            需要注意：折射率和下面将要阐述的 fresnel 折射系数并不是同样的东西。
            折射率本质上反映的是光在介质中的运行速度，以及折射方向；而 fresnel 折射
            系数反映的是，光在透明介质表面被折射的光通量的比率。
        }
        11.1.2 色散
        {
            色散分为正常色散和反常色散，通常我们所说的色散都是指反常色散，即，
            对光波透明的介质，其折射率随着波长的增加而减小。

            1672 年，牛顿利用三棱
            镜将太阳光分解为光谱色带（红橙黄绿蓝靛紫），这是人类首次所做的色散试验。
            天空中的彩虹也是由于光与水蒸气交互形成的色散现象（图 29 所示）。法国数
            学家柯西在 1936 年首先给出了正常色散的经验公式，称为柯西公式。

            计算机中的颜色是三原色，即只有红、绿、蓝三种颜色，给出光的红、绿、
            蓝分量的不同折射系数，可以近似模拟色散效果。

        }
        11.1.3 Fresnel定律
        {
            光线照射到透明物体上时，一部分发生反射，一部分进入物体内部并在介质
        交界处发生折射，被反射和折射的光通量存在一定的比率关系，这个比率关系可
        以通过 Fresnel 定律进行计算。

            根据 Fresnel 定律计算得出的数据称为 Fresnel 系数。严格而言， fresnel 系
        数分为 fresnel 反射系数和 fresnel 折射系数，通常我们所说的 fresnel 系数指 “ 反射
        系数 ” 。

        如果不做详细说明，则通常所写的 fresnel 系数指反射系数。
        一个完整的 fresnel 公式依赖于折射率、消光率和入射角度等因素，该公式的推导本质上是属于物理光学的部分
        
        schlick 给出了 Fresnel 反射系数的一个近似，精度在 1% 范围内：
            F = f0 + (1 - f0) * (1 - V dot H)^5

        f0 为入射角度接近0（入射方向靠近法向量）时Fresnel反射系数，V是指向视点的观察方向，H为半角向量。
        可以得出一个结论：随着入射角趋近 90 ，反射系数趋近 1 ，即擦地入射时，所有入射光都被反射。

        公式请见原书

        普通玻璃的反射系数大约是 4%
        }
    11.2 环境贴图
    {
        环境贴图（ Environment Mapping, EM ）也称为反射贴图（ Reflection Mapping ），用于模拟光滑表面对周围场景的映射效果
        环境贴图，顾名思义，在一副图片上展现周围的环境。
        环境贴图假设进行反射的光源和物体都位于很远的位置，同时反射体不会反射自身。最常被用到的环
        境贴图是立方体环境贴图

        该方法是将相机放置在环境的最中央，然后从上、下、左、右、前、后， 6 个方向拍摄周围环境，最后将这些信息投影到立方体的 6 个面上，所得到的纹理称之为立方体环境贴图。

        环境贴图的文件表现形式是一种纹理类型，例如立方体环境贴图在 DirectX
        中可以保存为 .dds 格式，也很多开源图形引擎中使用 6 个方向上的二维纹理动态
        组成环境贴图。

        除了立方体环境贴图，还有球面贴图、抛物面贴图。不过这两种贴图类型，与立方体环境贴图相比没有明显的优势。
        
        使用环境贴图，是为了模拟光滑表面对周围场景的映射效果。光滑表面对周
        围场景的映射，是由从场景出发的光线投射到光滑表面上然后被反射到人眼所形
        成的视觉效果

        我们将这个过程倒退回去，从视点发射一束射线到反射体上的一个点，然后
        这束射线以这个点为基准进行反射，并根据反射光线的方向向量检索环境图像的
        颜色。这就是环境贴图算法的基本思想。

        环境贴图算法的步骤如下：
        1. 首先根据视线方向和法向量计算反射向量；
        2. 然后使用反射向量检索环境贴图上的纹理信息；
        3. 最后将该纹理信息融合到当像素颜色中。

        环境贴图在 Cg 语言中属于 smaplerCUBE 类型变量，标准函数库中的
        texCUBE 函数提供依据反射方向向量检索环境贴图的功能。

        在代码 12 是使用立方体环境贴图实现环境映射效果的着色程序代码。在顶
        点着色程序中计算反射光线方向向量，然后传递到片段着色程序中，在片段着色
        程序中利用该方向检索环境贴图，获取纹理颜色，并进行片段赋值。整个实现过
        程非常简练。

        代码 12 实现环境映射效果的着色代程序
        void main_v( float4 position: POSITION,
                    float4 normal: NORMAL,
                    out float4 oposition : POSITION,
                    out float3 R : TEXCOORD1,
                    uniform float3 eyePosition,
                    uniform float4x4 modelViewProj,
                    uniform float4x4 modelToWorld)
        {
            oposition = mul( modelViewProj, position);
            //计算世界空间中的物体坐标和法向量
            float3 positionW = mul( modelToWorld, position).xyz;
            float3 normalW = mul( modelToWorld_IT, normal).xyz;
            normalW = normalize( normalW);
            float3 I = positionW - eyePosition;
            //计算反射光线 R.
            R = reflect( I, normalW );
        }
        void main_f( float3 R : TEXCOORD1,
                    out float4 color : COLOR,
                    uniform samplerCUBE environmentMap)
        {
            color = texCUBE( environmentMap, R);
        }

    }
    11.3 简单透明光照模型
    {
        简单透明光照模型不考虑透明物体对光的第二次折射、次表面散射，以及光
        在穿越透明物体时的强度衰减，只是简单的使用颜色调和的方法，即我们最终所
        看到的颜色，是物体表面的颜色和背景颜色的叠加。

        透明物体位于视点与另一个不透明物体之间，透明物体的不
        透明度为 t，点 A 为透明物体上的一点，点光源直接照射到 A 点上产生的反射光
        强为Ia ,视线穿过透明体与另一个物体相交处的光强为Ib ，
        则点 A 处的最终可观察的光强为：

        I = (1 - t)* Ib + t * Ia

        Ia和Ib 都可以用前面所讲的光照模型进行计算。
        通过透射光方向计算透射光强，首先需要进行光线和空间物体的求交运算，以确定透射光的来源，这是非常
        消耗时间的，如果真的这样做，其实就是演变为光线跟踪算法了。为了保证实时
        性，在实际使用中，通常是根据入射光方向向量和法向量求取折射光方向，然后
        根据折射光方向检索环境纹理上的颜色值作为Ib。

        简单透明光照模型的着色程序如下所示。依然是首先定义结构体，用来包含
        输入、输出数据流，然后在顶点着色程序中计算顶点投影坐标，并将顶点模型坐
        标和法向量坐标传递到片段着色程序中，然后在片段着色程序中计算折射光方向
        向量，并根据折射光向量检索环境贴图，最后按照公式进行颜色合成。
        Cg 标准函数库中的 lerp 函数可以提供颜色合成功能

        注意： 11.2 节所阐述的环境贴图方法，是使用反射光方向向量检索环境贴图；
        而在本节中，是使用折射光方向向量检索环境贴图。尽管都是检索环境贴图，但
        还是有区别的。

        代码 13 结构体
        struct VertexIn
        {
            float4 position : POSITION;
            float4 normal : NORMAL;
        };
        struct VertexScreen
        {
            float4 oPosition : POSITION;
            float4 objectPos : TEXCOORD0;
            float4 objectNormal : TEXCOORD1;
        };

        代码 14 简单透明光照模型顶点着色程序
        void main_v(VertexIn posIn,
                    out VertexScreen posOut,
                    uniform float4x4 modelViewProj)
        {
            posOut.oPosition = mul(modelViewProj, posIn.position);
            posOut.objectPos = posIn.position;
            posOut.objectNormal = posIn.normal;
        }

        代码 15 简单透明光照模型片段着色程序
        void main_f( VertexScreen posIn,
                    out float4 color : COLOR,
                    uniform float4x4 worldMatrix,
                    uniform float4x4 worldMatrix_IT,
                    uniform float3 globalAmbient,
                    uniform float3 eyePosition,
                    uniform float3 lightPosition,
                    uniform float3 lightColor,
                    uniform float3 Kd,
                    uniform float3 Ks,
                    uniform float shininess,
                    uniform float etaRatio, //折射系数
                    uniform float transmittance, //透明度
                    uniform samplerCUBE environmentMap //环境贴图
                    )
        {
            float3 worldPos = mul(worldMatrix, posIn.objectPos).xyz;
            float3 N = mul(worldMatrix_IT, posIn.objectNormal).xyz;
            N = normalize(N);
            //计算入射光方向\视线方向\半角向量
            float3 L = normalize(lightPosition - worldPos);
            float3 V = normalize(eyePosition - worldPos);
            float3 H = normalize(L + V);
            // 计算漫反射分量、镜面反射分量
            float3 diffuseColor = Kd * globalAmbient+Kd*lightColor*max(dot(N, L), 0);
            float3 specularColor = Ks * lightColor*pow(max(dot(N, H), 0), shininess);
            float3 reflectColor = diffuseColor+specularColor;
            //计算折射光线的方向,注意 refract 的输入参数！
            float3 I = normalize(worldPos - eyePosition);
            float3 T = refract(I, N, etaRatio);
            //根据折射光线的方向，检索环境贴图上的颜色信息
            float3 refractedColor = texCUBE(environmentMap, T).xyz;
            color.xyz = lerp(reflectColor, refractedColor, transmittance);
            color.w = 1;
        }
    }
    11.4 复杂透明光照模型与次表面散射
    {
        光射入透明物体时会发生一次反射和折射，光从透明物体内射出时，又会发
        生一次反射和折射。透明光照的简单模型实际上只是通过计算了第一次反射和折
        射，近似的模拟光透效果。

         2005 年， Wyman 在 ACM SIGGRAPH 大会上提出了
        在 GPU 中用近似的方法实现两次折射的透明物体绘制算法（ Interactive
        image-space refraction of nearby geometry ）。

        次表面散射是光射入半透明物体后再内部发生散射，最后射出物体并进入视野中产生的现象。
        次表面散射材质是高质量渲染中最复杂的材质之一，一个重要原因在于次表面散射物体内部的任何一点的光照度取决于体内其他点的光照度和材质本身的透光率。

        抛开材质本身的性质不说，这一特性使得次表面散射的光
        照方程变成一个复杂的微分方程，求出此方程的准确解是十分困难的，另一方面，
        材质本身可能具有复杂的各向异性和不均匀密度等性质，因此计算这样的积分变
        得非常困难。

        GPU 编程精粹第一部的第 16 章给出了一种次表面散射的实时近似模拟算法。
    }
12、投影纹理映射（Projective Texture Mapping）
{
        投影纹理映射（ Projective Texture Mapping ）最初由 Segal 在文章 “Fast shadows
    and lighting effects using texture maaping” 中提出，用于映射一个纹理到物体上，
    就像将幻灯片投影到墙上一样。该方法不需要在应用程序中指定顶点纹理坐标，
    实际上，投影纹理映射中使用的纹理坐标是在顶点着色程序中通过视点矩阵和投
    影矩阵计算得到的，通常也被称作投影纹理坐标 (coordinates in projective space) 。
    而我们常用的纹理坐标是在建模软件中通过手工调整纹理和 3D 模型的对应关系
    而产生的。

        投影纹理映射的目的是将纹理和三维空间顶点进行对应，这种对应的方法好
    比 “ 将纹理当作一张幻灯片，投影到墙上一样 ” 。

         本章我们针对投影纹理映射的原理和实现方法进行详细的阐述。这一章的地
    位很高，在一些阴影算法以及体绘制算法中都需要用到投影纹理映射技术。严格
    的说，只要涉及到 “ 纹理实时和空间顶点对应 ” ，通常都会用到投影纹理映射技术。
}
    12.1 投影纹理映射的优点
    {
        投影纹理映射有两大优点：其一，将纹理与空间顶点进行实时对应，不需要预先在建模软件中生成纹理坐标；其二，使用投影纹理映射，可以有效的避免纹理扭曲现象。
            为了说明第一个优点，先举一个简要的例子：很多情况下，我们需要将场景
        渲染两遍，第一遍是为了获取场景信息，得到的场景信息通常保存为一张纹理（例
        如深度图）；然后基于“存放场景信息”的纹理进行第二次渲染；第二次渲染结
        果才是最终显示到屏幕上的效果。为了在第二次渲染中使用到“存放场景信息”
        的纹理（无预先设置的纹理坐标），需要时时进行纹理计算，这时就可以使用投
        影纹理映射技术。实际上，这也是投影纹理映射技术的最广泛的应用了。

            在第 13 章的阴影贴图
        算法以及第 15 章的体绘制光线投射算法中，大家会明白其含义。一个算法只有
        理论加实践，才可能真正的被理解，只会照本宣科的朗诵术语，基本上都是鲁迅
        先生所说的 “ 泥塘 ” 似的人。

        投影纹理映射的第二个优点是：可以有效的避免纹理扭曲现象。将一张纹理投影到两个三角面片上，它们的顶点纹理坐标相同，但是由于三
        角面片形状不同，插值出来的内部点的纹理坐标也会产生不同的梯度（ gradient ），
        最后纹理颜色在两个三角面片上的分布也是不一样的。
    }
    12.2 齐次纹理坐标（Homogeneous Texture Coordinates）
    {
        齐次纹理坐标（ homogeneous texture coordinates ）的概念对大多数人来说比
        较陌生，纹理坐标一般是二维的，如果是体纹理，其纹理坐标也只是三维的。齐
        次纹理坐标的出现是为了和三维顶点的齐次坐标相对应，因为本质上，投影纹理
        坐标是通过三维顶点的齐次坐标计算得到的。

        齐次纹理坐标通常表示为（s,t,r,q）,以区别于物体位置齐次坐标(x, y, z,
        w)。一维纹理常用 s 坐标表示，二维纹理常用(s, t)坐标表示，目前忽略 r 坐标，
        q 坐标的作用与齐次坐标点中的 w 坐标非常类似。值一般为 1。
    }
    12.3 原理与实现流程
    {
        对投影纹理映射，很多教程上都是这么解释的：纹理好比一张幻灯片，灯光
        好比投影机，然后将纹理投影到一个物体上，类似于投影机将幻灯片投影到墙上。
        这个比喻没有太大的问题，也找不到更加形象的比喻了。

        问题是：这个解释刚好颠倒了算法的实现流程。
        投影纹理映射真正的流程是 “ 根据投影机（视点相机）的位置、投影角度，
        物体的坐标，求出每个顶点所对应的纹理坐标，然后依据纹理坐标去查询纹理
        值 ” ，也就是说，不是将纹理投影到墙上，而是把墙投影到纹理上。投影纹理坐
        标的求得，也与纹理本身没有关系，而是由投影机的位置、角度，以及 3D 模型
        的顶点坐标所决定。所以，我一直觉得 “ 投影纹理映射 ” 这个术语具有很强的误导
        性，总让人觉得是把纹理投射出去。

        根据顶点坐标获得纹理坐标的本质是将顶点坐标投影到 NDC 平面上，此时
        投影点的平面坐标即为纹理坐标。如果你将当前视点作为投影机，那么在顶点着
        色程序中通过 POSTION 语义词输出的顶点投影坐标，就是当前视点下的投影纹
        理坐标没有被归一化的表达形式。

        计算投影纹理坐标需要将投影顶点坐标归一化
        到【0，1】空间中，实现这一步，可以在需要左乘矩阵 normalMatrix , 也可以在
        着色程序中对顶点投影坐标的每个分量先乘以1/2然后再加上1/2。
                        |   0.5 0   0   0.5 |
                        |   0   0.5 0   0.5 |
        normalMatrix =  |   0   0   0.5 0.5 |
                        |   0   0   0   1   |
        求取投影坐标矩阵的公式为：
        texView ojMatrix biasMatrix projectionMatrix viewMatrix worldMatrix

        求得纹理投影矩阵后，便可以使用该矩阵将顶点坐标转换为纹理投影坐标。
        texView ojCoordinate texViw ojMatrix elCoordinate

        使用投影纹理坐标之前，别忘了将投影纹理坐标除以最后一个分量q。到此，
        你就可以使用所求得的投影纹理坐标的前两个分量去检索纹理图片，从中提取颜
        色值。
        还记得Cg标准函数库中有的纹理映射函数的表达形式为：
        tex2DProj(sampler2D tex, float4 szq)
        tex2DProj 函数与 tex2D 函数的区别就在于：前者会对齐次纹理坐标除以最后一个分量 q ，然后再进行纹理检索！

        注意：上面常被提到的“投影机”只是一种形象化的比喻，本质是视点相机，
        很多教程上都说“将灯光当作投影机”，这是一种错误的表达（并非是这些教程
        的作者不懂，而是语言组织上的错误），他们真正的意思是“在当前灯光所在的
        位置放置一个相机，相机的观察方向和光线投射方向一致”，这个相机就作为投
        影机使用。在一些阴影算法中，根据光源信息设置投影机，并从投影机的角度渲
        染出场景信息纹理（如，阴影纹理），然后把这个纹理放到正常的场景渲染相机
        中使用，这时就需要投影机的矩阵信息来建立投影纹理矩阵了。

        附：投影纹理矩阵的计算通常不需要开发人员自己动手，常用的图形API中
        都给出了获取各种矩阵（视点矩阵、投影矩阵等）的函数，不过偏移矩阵需要自
        己设置。在应用程序中获取这些矩阵信息后，再传递到着色程序中使用。

        代码 16 投影纹理映射顶点着色程序
        void main_v(
            float4 position  : POSITION,
            float4 normal  : NORMAL,
            out float4 outPos : POSITION,
            out float4 outShadowUV : TEXCOORD0,
            uniform float4x4 worldMatrix,
            uniform float4x4 worldViewProj,
            uniform float4x4 texViewProj //投影纹理矩阵
            )
        {
            outPos = mul(worldViewProj, position);
            // 计算投影纹理坐标
            float4 worldPos = mul(worldMatrix, position);
            outShadowUV = mul(texViewProj, worldPos);
        }

        代码 17 投影纹理映射片段着色程序
        void main_f(
            float4 shadowUV  : TEXCOORD0,
            out float4 result : COLOR,
            uniform sampler2D projectiveMap //用于投影的纹理
            )
        {
            shadowUV = shadowUV / shadowUV.w;
            float4 mapColor ;
            //归一化到 0-1 空间
            shadowUV.x = (shadowUV.x +float(1.0))/float(2.0);
            shadowUV.y = (shadowUV.y +float(1.0))/float(2.0);
            mapColor = tex2D(projectiveMap, shadowUV.xy);
            result = mapColor;
        }
    }
    12.4 本章小结
    {
        本章对投影纹理映射的基本原理和实现流程进行了阐述，这项技术虽然并不复杂，但是却很基础。
    }
13、Shadow Map
{
        Shadows are created by testing whether a pixel is visible from the light source,
    by comparing it to a z-buffer or depth image of the light source's view, stored in the
    form of a texture.

    Shadow Map 是一种基于深度图（depth map）的阴影生成方法，由 Lance
    Williams 于 1978 年在文章“ Casting curved shadows on curved surfaces ”中首次提
    出。该方法的主要思想是：在第一遍渲染场景时，将场景的深度信息存放在纹理
    图片上，这个纹理图片称为深度图；然后在第二次渲染场景时，将深度图中的信
    息lenth1 取出，和当前顶点与光源的距离lenth2 做比较，如果lenth1 小于lenth2 ，
    则说明当前顶点被遮挡处于阴影区，然后在片段着色程序中，将该顶点设置为阴
    影颜色。
}
    13.1 什么是depth map
    {
                深度图是一张 2D 图片，每个像素都记录了从光源到遮挡物（遮挡物就是阴
        影生成物体）的距离，并且这些像素对应的顶点对于光源而言是 “ 可见的 ” 。这里
        的 “ 可见 ” 像素是指，以光源为观察点，光的方向为观察方向，设置观察矩阵并渲
        染所有遮挡物，最终出现在渲染表面上的像素。

        Depth map 中像素点记录的深度值记为lenth1 ；然后从视点的出发，计算物体顶点 v 到光源的距离，记为lenth2 ；比较lenth1 与lenth2 的大小，如果lenth2 >lenth1，则说明顶点 v 所对应的 depth texure 上的像素点记录的深度值，并不是 v 到光源的距离，而是 v 和光源中间某个点到光源的距离，这意味着 “ v 被遮挡 ” 。
        在一些教程中，往往将 depth map 翻译成阴影贴图（ shdaow texture ），这实在是一个误解，不光误解了两个名称，也混淆了 2 种阴影算法。

        阴影贴图的英文为 Shadow texture ，就是将日常所见的阴影保存为纹理图片；
        Depth texture 保存的是 “ 从视点到物体顶点的距离，通常称为深度值 ” 。

        此外， Shadow texture 不但表示阴影贴图，也代表了一种阴影渲染方法，其
        实就是将阴影贴图作为纹理投影到物体上，投影的方法采用前面所讲述的 texture
        projective 方法。
    }
    13.2 Shadow map 与Shadow texture的区别
    {
        在很多中文资料中，论述 Shadow ma p 技术时，容易将 Shadow map 与 shadowtexture 这两个不同的概念混淆；
        在英文中 map 有映射和图片的双重含义在内， shadow map 技术称为“ shadow map ”在英文中应该是准确的。
        一定要知道“阴影图” 和 shadow texture 所谓的阴影贴图是完全不同的两个概念

        Shadow map 以 depth map 为技术基础，通过比较“光源可见点到光源的深度”和“任何点到光源的深度”来判断点是否被物体遮挡；

        而 shadow texture 技术，将生成的阴影图形作为
        投影纹理来处理，也就是将一张阴影图投影映射到一个物体上（阴影接收体）。
        这种方法的缺点在于:设计者必须确认哪个物体是遮挡物，哪个物体是阴影接受
        体，并且不能产生自阴影现象（将一个物体的阴影贴图贴到物体身上，这是多么
        怪异）。
    }
    13.3 Shadow map 原理与实现流程
    {
        使用 Shadow Map 技术渲染阴影主要分两个过程：生成 depth map (深度图) 和使用 depth map 进行阴影渲染。
        生成 depth map 的流程为：
        1. 以光源所在位置为相机位置，光线发射方向为观察方向进行相机参数设置；
        2. 将世界视点投影矩阵 worldViewProjMatrix 传入顶点着色程序中，并在
            其中计算每个点的投影坐标，投影坐标的 Z 值即为深度值（将 Z 值保存为深
            度值只是很多方法中的一种）。在片段 shadow 程序中将深度值进行归一化，
            即转化到【0，1】区间。然后将深度值赋给颜色值（ Cg 最的颜色值范围在
            0-1 之间）。

        这里有一点要留心： depth map 中保存的深度值到底是什么？很多文献都将
        depth map 深度值解释成 Z Buffer 中的 Z 值，我对这种解释一直持怀疑态度！并
        不是说这种解释不对，而是指 “ 这种解释有以偏概全的嫌疑 ” 。我们通常所说的距
        离是指笛卡尔坐标空间中的欧几里得距离（ Euclidean distance ）， Z 值本身并不
        是这个距离（参阅第 2.4.2 节），此外我在研究 GPU 算法的过程中，看到的关于
        depth map 中保存的深度值的计算方法远不止一种，有些直接计算顶点到视点的
        距离，然后归一化到【 0 ， 1 】空间，同样可以有效的用于深度比较。由此可见，
        depth map 中保存的深度值，是衡量 “ 顶点到视点的距离 ” 相对关系的数据，计算
        深度值的重点在于 “ 保证距离间相对关系的正确性 ” ，至于采用什么样的计算方法
        倒在其次。

        3. 从 frame buffer 中读取颜色值，并渲染到一张纹理上，就得到了 depth
        map 。
        注意：在实际运用中，如果遇到动态光影，则 depth map 通常是实时
        计算的，这就需要场景渲染两次，第一次渲染出 depth map ，然后基于 depth
        map 做阴影渲染。

        渲染 depth map 的顶点着色程序和片段着色程序分别为：
        
        代码 18 渲染 depth map 的顶点着色程序

        void main_v(float4 position  : POSITION,
                    out float4 oPosition : POSITION,
                    out float2 depth : TEXCOORD0,
                    uniform float4x4 worldViewProj )
        {
            oPosition = mul(worldViewProj, position);
            // 存放深度值
            depth.x = oPosition.z;
            depth.y = oPosition.w;
        }

        代码 19 渲染 depth map 的片段着色程序
        void main_f(float2 depth : TEXCOORD0,
                    out float4 result  : COLOR,
                    uniform float pNear ,
                    uniform float pFar,
                    uniform float depthOffset )
        {
            float depthNum = 0.0;
            //归一化到 0-1 空间
            depthNum = (depth.x - pNear) / (pFar - pNear);
            depthNum += depthOffset;
            result.xyz = depthNum.xxx;
            result.w = 1.0;
        }

        在代码 19 的片段着色程序中，有一个外部输入变量 depthOffset ，该变量表
        示深度值的偏移量，这是因为:将深度值写入纹理颜色，会导致数据精度的损失，
        所以需要加上一个深度偏移量。这个偏移量自己设定，通常是 0.01 之类的微小
        数据。

        使用 depth map 进行阴影渲染的流程为：
        1. 将纹理投影矩阵传入顶点着色程序中。注意，这个纹理投影矩阵，实际
            上就是产生深度图时所使用的 worldViewProjMatrix 矩阵乘上偏移矩阵（具
            体参见第 13 章），根据纹理投影矩阵，和模型空间的顶点坐标，计算投影纹
            理坐标和当前顶点距离光源的深度值lenth2 （深度值的计算方法要和渲染深
            度图时的方法保持一致）。
        2. 将 depth map 传入片段着色程序中，并根据计算好的投影纹理坐标，从中获取颜色信息，该颜色信息就是深度图中保存的深度值lenth1 。
        3. 比较两个深度值的大小，若lenth2 大于lenth1 ，则当前片断在阴影中；否则当前片断受光照射。

        代码 20 使用 depth map 进行阴影渲染的顶点着色程序
        void main_v(float4 position : POSITION,
                    float4 normal  : NORMAL,
                    float2 tex : TEXCOORD,
                    out float4 outPos : POSITION,
                    out float4 outShadowUV : TEXCOORD0,
                    uniform float4x4 worldMatrix,
                    uniform float4x4 worldViewProj,
                    uniform float4x4 texViewProj)
        {
            outPos = mul(worldViewProj, position);
            float4 worldPos = mul(worldMatrix, position);
            // 计算投影纹理坐标
            outShadowUV = mul(texViewProj, worldPos);
        }

        代码 21 使用 depth map 进行阴影渲染的片段着色程序
        void main_f(float4 position : POSITION,
                    float4 shadowUV  : TEXCOORD0,
                    out float4 result : COLOR
                    uniform sampler2D shadowMap ,
                    uniform float pNear ,
                    uniform float pFar,
                    uniform float depthOffset,
                    uniform int pixelOffset)
        {
            //计算当前顶点和光源之间的距离（相对）
            float lightDistance = (shadowUV.z - pNear) / (pFar - pNear);
            lightDistance = lightDistance - depthOffset;
            shadowUV.xy = shadowUV.xy/ shadowUV.w;
            //进行多重采样，减小误差
            float4 depths = float4(
            tex2D(shadowMap, shadowUV.xy + float2(-pixelOffset, 0)).x,
            tex2D(shadowMap, shadowUV.xy + float2(pixelOffset, 0)).x,
            tex2D(shadowMap, shadowUV.xy + float2(0, -pixelOffset)).x,
            tex2D(shadowMap, shadowUV.xy + float2(0, pixelOffset)).x);
            float centerdepth = tex2D(shadowMap, shadowUV.xy).x;
            //进行深度比较
            float l_Lit = (lightDistance >= centerdepth? 0 : 1);
            l_Lit += (lightDistance >= depths.x? 0 : 1);
            l_Lit += (lightDistance >= depths.y? 0 : 1);
            l_Lit += (lightDistance >= depths.z? 0 : 1);
            l_Lit += (lightDistance >= depths.w? 0 : 1);
            l_Lit *= 0.2f;
            result = float4(l_Lit, l_Lit, l_Lit, 1.0);
        }

        Shadow map 方法的优点是可以使用一般用途的图形硬件对任意的阴影进行
        绘制，而且创建阴影图的代价与需要绘制的图元数量成线性关系，访问阴影图的
        时间也固定不变。此外，可以在基于该方法进行改进，创建软阴影效果。所谓软
        阴影就是光学中的半影区域。如果实时渲染软阴影，并运用到游戏中，是目前光
        照渲染领域的一个热门研究方向。
        但 Shadow map 方法同样存在许多不足之处：
        其一：阴影质量与阴影图的分辨率有关，所以很容易出现阴影边缘锯齿现象；
        其二：深度值比较的精确度和正确性，有赖于 depth map 中像素点的数据精
            度，当生成深度图时肯定会造成数据精度的损失。要知道，深度值最后都被归一
            化到 0 ， 1 空间中，所以看起来很小的精度损失也会影响数据比较的正确性，尤
            其是当两个点相聚非常近时，会出现 z-fighting 现象。所以往往在深度值上加上
            一个偏移量，人为的弥补这个误差；
        其三：自阴影走样（ Self-shadow Aliasing ） , 光源采样和屏幕采样通常并不一
        定在完全相同的位置，当深度图保存的深度值与观察表面的深度做比较时，其数
        值可能会出现误差，而导致错误的效果，通常引入偏移因子来避免这种情况；
        其四：这种方法只适合于灯类型是聚光灯（ Spot light  ）的场合。如果灯类
        型是点光源（ Point light ）的话，则在第一步中需要生成的不是一张深度纹理，
        是一个立方深度纹理（ cube texture ）。如果灯类型是方向光（ Directional light ）
        的话 , ，则产生深度图时需要使用平行投影坐标系下的 worldViewProjMatrix 矩阵；

        当前广泛使用的阴影算法中有一种被称之为模板（ stencil ）阴影算法。模板
        阴影算法在游戏中得到广泛的使用，在当前主流的开源图形引擎中，基本都集成
        了该算法。为了对比 shadow map 方法，特地在本书的附录 C 中对其进行阐述。
    }
14、体绘制（Volume Rendering）概述
{
    1982 年 2 月，美国国家科学基金会在华盛顿召开了科学可视化技术的首次
    会议，会议认为“科学家不仅需要分析由计算机得出的计算数据，而且需要了解
    在计算过程中的数据变换，而这些都需要借助于计算机图形学以及图像处理技
    术”。

    自 20 世纪 80 年代科学计算可视化（ Visualization in Scientific Computing ）
    被提出后，三维体数据的可视化逐渐称为发展的重点，并最终形成了体绘制技术
    领域。

    一些文章，甚至是优秀硕博士论文库上的文章，解释体绘制概念时，通常都
    说 “ 体绘制技术是直接根据三维体数据场信息产生屏幕上的二维图像 ” ，这种说法
    太过含糊，如果根据三维体数据场信息随便产生一张图像，难道也是体绘制吗？
    
     M.Levoy  在文章 “Display of surfaces from volume data”( 文献【 14 】 ) 中提到 “volume rendering
    describes a wide range of techniques for generating images from three-dimensional
    scalar data”  ，翻译过来就是 “ 体绘制描述了一系列的 “ 根据三维标量数据产生二维
    图片 ” 的技术 ” 

    注意，人家文章中用的是 “ 描述 ” ，而不是对体绘制下定义。老实
    说，老外的这种说法虽然挑不出毛病，但是我依然感觉没有落实到重点。

    体绘制的核心在于 “ 展示体细节！而不是表面细节 ” 。我给出的定义是：依据
    三维体数据，将所有体细节同时展现在二维图片上的技术，称之为体绘制技术。
    利用体绘制技术，可以在一幅图像中显示多种物质的综合分布情况，并且可以通
    过不透明度的控制，反应等值面的情况。

        例如， CT 图片中展示的是人体的肌肉和骨骼信息，而不是表面信息（那是
    照片）。所以理解体绘制和面绘制技术的区别的 , 一个很直观的比喻是：普通照相
    机照出的相片和 CT 仪器拍出的 CT 照片，虽然都是二维图片，但是展现的对象是不同的！
}
    14.1 体绘制与科学可视化
    {
        科学可视化技术是运用计算机图形学、图像处理、计算机视觉等方法，将科
        学、工程学、医学等计算、测量过程中的符号、数字信息转换为直观的图形图像，
        并在屏幕上显示的理论、技术和方法。

        体绘制是科学可视化领域中的一个技术方向。如前所述，体绘制的目标是在
        一副图片上展示空间体细节。举例而言，你面前有一间房子，房子中有家具、家
        电，站在房子外面只能看到外部形状，无法观察到房子的布局或者房子中的物体；
        假设房子和房子中的物体都是半透明的，这样你就可以同时查看到所有的细节。
        这就是体绘制所要达到的效果。
    }
    14.2 体绘制应用领域
    {
        人类发展史上的重大技术带来的影响大致分为两种：其一，技术首先改变生
        活本身，然后改变人类对世界的看法，例如电视、电话等；还有一种技术，是首
        先改变人类对世界的看法，然后改变生活本身，例如伦琴射线、望远镜。

        体绘制技术应该属于后者，通过改变所见，而改变生活。体绘制计算的重要
        意义，首先在于可以在医疗领域 server the people, 有助于疾病的诊断，这一点应
        该不用多说，计算机断层扫描（ CT ）已经广泛应用于疾病的诊断。医疗领域的
        巨大需求推动了体绘制技术的告诉发展，如果了解 CT 的工作原理，也就大致了
        解了体绘制技术原理和流程。

            其二，体绘制计算可以用于地质勘探、气象分析、分子模型构造等科学领域。
        我在工作期间承担的一个较大的项目便是有关 “ 三维气象可视化 ” ，气象数据通常
        非常庞大，完全可以号称海量数据，每一个气压面上都有温度、湿度、风力风向
        等格点数据，气象研究人员希望可以同时观察到很多气压面的情况，这时就可以
        采用体绘制技术，对每个切面（气压面）进行同时显示。

        体绘制技术也能用于强化视觉效果，自然界中很多视觉效果是不规则的体，
        如流体、云、烟等，它们很难用常规的几何元素进行建模，使用粒子系统的模拟
        方法也不能尽善尽美，而使用体绘制可以达到较好的模拟效果。
    }
    14.3 体绘制与光照模型
    {
        尽管光照模型通常用于面绘制，但是并不意味着体绘制技术中不能使用光照
        模型。实际上 , 体绘制技术以物体对光的吸收原理为理论基础，在实现方式上，
        最终要基于透明度合成计算模型。

        此外，经典的光照模型，例如 phong 模型，cook-torrance 模型都可以做为体绘制技术的补充，完善体绘制效果，增强真实感。

        往往有初学者会分不清 “ 体绘制技术 ” 以及 “ 透明光照模型 ” 之间的区别。
            这个问题很有意思。实际上，体绘制技术与透明光照模型在感性认识上十分类似，在
        很多教程中对体绘制技术的阐述也涉及到透明物体。
            但是，透明光照模型，一般
        侧重于分析光在透明介质中的传播方式（折射，发散，散射，衰减等），并对这
        种传播方式所带来的效果进行模拟；而体绘制技术偏重于物体内部层次细节的真
        实展现。

        举例而言，对于一个透明的三棱镜，使用透明光照模型的目的在于 “ 模
        拟光的散射，折射现象（彩虹） ” ；而对于地形切片数据或者人体数据，则需要
        使用体绘制技术观察到其中的组织结构。此外，在实现方式上，透明光照模型一
        般是跟踪光线的交互过程，并在一系列的交互过程中计算颜色值；而体绘制技术
        是在同一射线方向上对体数据进行采样，获取多个体素的颜色值，然后根据其透
        明度进行颜色的合成。

        总的来说，透明光照模型侧重于光照效果展现，并偏向艺术化；而体绘制技
        术侧重展现物质内部细节，要求真实！

        不过，现在体绘制技术实际上也可以用于艺术领域，因为体绘制技术所使用
        的方法，实际上具有很强的通用性，尤其是传统的 ray-cast 方法，完全可以应用
        到透明光照模型中（绘制烟雾等）。不同的技术之间会存在共融性，将技术和领
        域的关系近固化，是研究人员的大忌。
        科学史上很多前例都说明了一个事实：不
        同领域的交合点，往往会出现重大发现或发明。在爱因斯坦之前，又有谁知道时
        间、空间和质量之间的关系呢？
    }
    14.4 体数据（Volume Data）
    {
        学习任何一门技术，首先要弄清楚这项技术的起源以及数据来源。技术的起
        源也就是技术最原始的需求，最原始的发展动力，了解了这一点就了解了这项技
        术的价值。而了解一门技术的数据来源，就把握了技术的最初脉络，是 “ 持其牛
        耳 ” 的一种方法，正如软件工程中的数据流分析方法一般。

        我很想说，体数据与面数据的区别，就好像一个实心的铁球和一个空心的兵
        乓球的区别。不过这个比喻很显然有点俗，很难让人相信作者（我）是一个专业
        人士。于是我决定还是将与体数据相关的专业术语都阐述一遍。

        不过，在此之前，我需要先消除大家的恐惧感，研究表明，动物对于未知事
        物总是存在恐惧感，这也是阻碍进一步学习的关键所在。体数据不是什么特别高
        深的火星符号，它是对一种数据类型的描述，只要是包含了体细节的数据，都可
        以称之为体数据。举个例子，有一堆混凝土，其中包含了碳物质（ C ）若干，水
        分子（ H20 ）若干，还有不明化学成分的胶状物，你用这种混凝土建造了块方砖，
        如果存在一个三维数组，将方砖 X 、 Y 、 Z 方向上的物质分布表示出来，则该数
        组可以被称为体数据。不要小看上面这个比喻，体数据本质上就是按照这个原理
        进行组织的！

        体数据一般有 2 种来源：
        1. 科学计算的结果，如：有限元的计算和流体物理计算；
        2. 仪器测量数据，如： CT 或 MRI 扫描数据、地震勘测数据、气象检测数据等。

        体数据相关的专业术语有：体素（ Voxel ）、体纹理（ Volume Texture ）。
        尤其要注意：所谓面数据，并不是说二维平面数据，而是说这个数据中只有表面细
        节，没有包含体细节，实际上体数据和面数据的本质区别，在于是否包含了体细
        节，而不是在维度方面。

    }
        14.4.1 体素(Voxel)
        {
            Wikipedia 中对体素 voxel 的介绍为：
            A voxel (a portmanteau of the words volumetric and pixel) is a volume element,
            representing a value on a regular grid in three dimensional space. This is analogous to
            a pixel, which represents 2D image data in a bitmap 。

            即 “ 体素，是组成体数据的最小单元，一个体素表示体数据中三维空间某部
            分的值。体素相当于二维空间中像素的概念 ” 。
            体素不存在绝对空间位置的概念，只有在体空间中的相对位置，这一点和像素是一样的。

            通常我们看到的体数据都会有一个体素分布的描述，即，该数据由 n*m*t 个
            体素组成，表示该体数据在 X 、 Y 、 Z 方向上分别有 n 、 m 、 t 个体素。在数据表达
            上，体素代表三维数组中的一个单元。假设一个体数据在三维空间上 256*256*256
            个体素组成，则，如果用三维数组表示，就必须在每一维上分配 256 个空间。

            在实际的仪器采样中，会给出体素相邻间隔的数据描述，单位是毫米（ mm ），
            例如 0.412mm 表示该体数据中相邻体素的间隔为 0.412 毫米。
        }
        14.4.2 体纹理（Volume Texture）
        {
            体数据最主要的文件格式是 “ 体纹理（ volume texture ） ” ！故而，非常有必要对体纹理的概念进行详细的阐述。

            目前，学术性文章中关于体纹理的概念描述存在不小的混乱，很多书籍或者
            网页资料没有明确的区分 2d texture ， 3d texture ， volume texture 之间的区别。导致
            不少人认为 “ 只要是用于三维虚拟或仿真技术中的纹理都称之为 3d texture” 。这是
            一个误会。纹理上的 2 ， 3 维之分本质上是根据其所描述的数据维数而定的，所谓
            2d texture 指的是纹理只描述了空间的面数据，而 3d texture 则是描述了空间中的三
            维数据。 
            3d texture 另一个较为学术化的名称是： volume texture 。
            
            22  www.tech-faq.com3d-texture.shtml# 对 体纹理的定义是:

            3D texture (Three Dimensional Texture), also known as "volume texture," is a
            logical extension of the traditional (and better known) 2D texture. In this context, a
            texture is simply a bitmap image that is used to provide surface coloring for a 3D
            model. A 3D texture can be thought of as a number of thin pieces of texture used to
            generate a three dimensional image map. 3D textures are typically represented by 3
            coordinates.

            翻译成中文就是 “ 三维纹理，即体纹理，是传统 2D 纹理在逻辑上的扩展。二
            维纹理是一张简单的位图图片，用于为三维模型提供表面点的颜色值；而一个三
            维纹理，可以被认为由很多张 2D 纹理组成的，用于描述三维空间数据的图片。
            三维纹理通过三维纹理坐标进行访问 ” 。

            从上面这句话，可以得到两点信息：
            1. 三维纹理和体纹理是同一概念；三维纹理和二维纹理是不同的；
            2. 三维纹理通过三维纹理坐标进行访问。

            这时可能会有人提出问题了，图片都是平面的，怎么能表示三维数据？请注
            意，我们通常所看到的图片确实都是平面的，但是并不意味着 x,y 平面上的像素
            点不能存放三维数据，举一个例子：在高级语言编程中，我们完全可以用一维数
            组去存放三维数组中的数据，只要按照一定规则存放即可！
            按照一定规则将三维数据存放在 XY 像素平面所得到的纹理，称之为 volume
            texture 。

            体数据通常是由 CT 仪器进行扫描得到的，然后保存在图片的像素点上。目
            前国际上比较常用的体纹理格式有，基于 DirectX 的 .dds 格式和 .raw 格式。注意，
            很多人会将 .raw 格式当作摄像器材使用的那种格式，其实这两个格式的后缀虽然
            都是 .raw ，但是其数据组织形式是不同的。用于体纹理的 .raw 格式，存放的是三
            维数据，用于摄像器材的 .raw 格式只是普通的二维图片。

        }
    14.5 体绘制算法
    {
        国际上留下的体绘制算法主要有：光线投射算法（ Ray-casting ）、错切 - 变形
        算法（ Shear-warp ）、频域体绘制算法（ Frequency Domain ）和抛雪球算法
        （ Splatting ）。其中又以光线投射算法最为重要和通用。

        究其原因，无外乎有三点：其一，该算法在解决方案上基于射线扫描过程，
        符合人类生活常识，容易理解；其二，该算法可以达到较好的绘制效果；其三，
        该算法可以较为轻松的移植到 GPU 上进行实现，可以达到实时绘制的要求。
    }
15、光线投射算法（Ray Casting）
    15.1 光线投射算法原理
    {
        光线投射方法是基于图像序列的直接体绘制算法。
        从图像的每一个像素，沿
        固定方向（通常是视线方向）发射一条光线，光线穿越整个图像序列，并在这个
        过程中，对图像序列进行采样获取颜色信息，同时依据光线吸收模型将颜色值进
        行累加，直至光线穿越整个图像序列，最后得到的颜色值就是渲染图像的颜色。

        为什么在上面的定义是穿越 “ 图像序列 ” ，而不是直接使用 “ 体纹理 ” ？原因在
        于，体数据有多种组织形式，在基于 CPU 的高级语言编程中，有时并不使用体
        纹理，而是使用图像序列。在基于 GPU 的着色程序中，则必须使用体纹理。这
        里所说的图像序列，也可以理解为切片数据。

            尤其要注意：光线投射算法是从视点到 “ 图像序列最表面的外层像素 ” 引射线
        穿越体数据，而不少教程中都是糊里糊涂的写到 “ 从屏幕像素出发 ” ，这种说法太
        过简单，而且很容易让人误解技术的实现途径，可以说这是一种以讹传讹的说法！
        从屏幕像素出发引出射线，是光线跟踪算法，不是光线投射算法。

        体绘制中的光线投射方法与真实感渲染技术中的光线跟踪算法有些类似，即
        沿着光线的路径进行色彩的累计。但两者的具体操作不同。首先，光线投射方法
        中的光线是直线穿越数据场，而光线跟踪算法中需要计算光线的反射和折射现
        象。其次，光线投射算法是沿着光线路径进行采样，根据样点的色彩和透明度，
        用体绘制的色彩合成算子进行色彩的累计，而光线跟踪算法并不刻意进行色彩的
        累计，而只考虑光线和几何体相交处的情况；最后，光线跟踪算法中光线的方向
        是从视点到屏幕像素引射线，并要进行射线和场景实体的求交判断和计算，而光
        线投射算法，是从视点到物体上一点引射线（ 16.1.2 节会进行详细阐述），不必
        进行射线和物体的求交判断。
    }
        15.1.1 吸收模型
    
    15.2 光线投射算法若干细节之处
        15.2.1 光线如何穿越体纹理
        15.2.2 透明度、合成
        15.2.3 沿射线进行采样
        15.2.4 如何判断光线投射出体纹理
    15.3 算法流程
    15.4 光线投射算法实现
    15.5 本章小结


{
    三个顶点通常按逆时针顺序组成一个三角面
}
只要你走得足够远，你肯定能到某个地方


