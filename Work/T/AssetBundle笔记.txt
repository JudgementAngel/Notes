1、AssetBundle 是一个压缩包包含模型、贴图、预制体、声音、甚至整个场景，可以在游戏运行的时候被加载；
2、AssetBundle 自身保存着互相的依赖关系
3、压缩包可以使用LZMA和LZ4压缩算法，减少包大小，更快地进行网络传输
4、把一些可以下载内容放在AssetBundle里面，可以减少安装包大小

5、AssetBundle是一个存在于硬盘上的文件。可以称之为压缩包。这个压缩包可以认为是一个文件夹，里面包含了很多文件。serialized file (序列化文件)和resource files(源文件)
serialized file：资源被打碎放在一个对象中，最后统一被写进一个单独的文件
resource files：某些二进制资源（图片、声音）被单独保存，方便快速加载
6、AssetBundle也是一个对象，可以通过代码从一个特定的压缩包加载出来的对象。这个对象包含了我们当初添加到压缩包里面的内容，我们可以通过这个对象加载出来使用 

7、指定AssetBundle的属性、构建AssetBundle包、上传AB包、加载AB包和包里面的资源 
8、使用assetbundle作为AssetBundle包的结尾容易被破解
9、AssetBundle的相对路径是以工程的根目录路径为准的
10、Build出来的包是有平台限制的
AssetBundle会为当前文件夹目录生成一个对应AssetBundle文件，表示这个目录有的AssetBundle的信息，只会给生成目录生成，子目录是没有的
11、LoadAsset<GameObject>("xxx");//这里是区分大小写的

12、AssetBundle分组策略
    1、逻辑实体分组：
        a、一个UI界面或者所有UI界面一个包（这个界面里面的贴图和布局信息一个包）
        b、一个角色或者所有角色一个包（这个角色里面的模型和动画一个包）
        c、所有的场景所共享的部分一个包（包括贴图和模型）
    2、按照类型分组：
        所有声音资源打一个包，所有Shader打成一个包，所有模型打成一个包，所有材质打成一个包
    3、按照使用分组：
        把在某一时间内使用的所有资源打成一个包。可以按照关卡分，一个关卡所需要的所有资源，包括角色、贴图、声音等打成一个包。也可以按照场景分，一个场景所需要的资源一个包
13、分组策略-总结
    1、把经常更新的资源放在一个单独的包里面，跟不经常更新的包分离
    2、把需要同时加载的资源放在一个包里面
    3、可以把其他包共享的资源放在一个单独的包里面
    4、把一些需要同时加载的小资源打包成一个包
    5、如果对于一个同一个资源有两个版本，可以考虑通过后缀来区分 v1 v2  v3
14、打包每一个资源的时候，它会打包它所引用的资源

15、共享（依赖）打包

16、BuildAssetBundleOptions 主要的三个方法
    1、None：使用LZMA算法压缩，压缩的包更小，但是加载时间更长。使用之前需要整体解压。一旦被解压，这个包会使用LZ4重新压缩。使用资源的时候不需要整体解压。在下载的时候可以使用LZMA算法，一旦它被下载了之后，它会使用LZ4算法保存到本地上。
    2、UncompressedAssetBundle：不压缩，包大，加载快
    3、ChunkBasedCompression：使用LZ4压缩，压缩率没有LZMA高，但是我们可以加载指定资源而不用解压全部

    注意使用LZ4压缩，可以获得可以跟不压缩相媲美的加载速度，而且比不压缩文件要小

17、CRC和MD5的作用是一样的
18、manifest里面也存有依赖的资源
19、包的加载顺序无所谓，主要是在使用里面的内容的时候，必须了两个包都加载出来才行，如果有一个没有加载出来，就会出现问题

20、AssetBundle.LoadFromMemory(Async) 从内存中加载(异步)
    AssetBundle.LoadFromFile         从文件中加载
    WWW.LoadFromCacheOrDownload      从服务器或者Cache中加载
    UnityWebRequest                  用来取代上面的从Web上加载
21、LoadFromCacheOrDownload使用这个方法去加载AB，如果你的资源是使用LZMA算法压缩的，它会开启一个线程去解压，解压完之后放在Cache中 

22、yield break 中断协程
23、WWW.LoadFromCacheOrDownload(string path,int version);这里的path如果是从本地取文件要加上 file:///，这里也可以是一个网址
24、uri 统一资源定位

25、manifest.GetAllAssetBundles();//用来取得所有包的名字 

26、AssetBundle的卸载
    1、减少内存使用
    2、有可能导致丢失
    AssetBundle.Unload(true);//卸载所有资源，即使有资源被使用着（1、在关卡切换、场景切换；2、资源没有被使用的时候调用）
    AssetBundle.Unload(false);//卸载所有没有被使用的资源个别资源怎么卸载1，通过 Resources.UnloadUnusedAssets.  2，场景切换的时候   
27、文件校验：
    CRC MD5 SHA1
    相同点：
    CRC、MD5、SHA1都是通过对数据进行计算，来生成一个校验值，该校验值用来校验数据的完整性。
    不同点：
    1. 算法不同。CRC采用多项式除法，MD5和SHA1使用的是替换、轮转等方法；
    2. 校验值的长度不同。CRC校验位的长度跟其多项式有关系，一般为16位或32位；MD5是16个字节（128位）；SHA1是20个字节（160位）；
    3. 校验值的称呼不同。CRC一般叫做CRC值；MD5和SHA1一般叫做哈希值（Hash）或散列值；
    4. 安全性不同。这里的安全性是指检错的能力，即数据的错误能通过校验位检测出来。CRC的安全性跟多项式有很大关系，相对于MD5和SHA1要弱很多；MD5的安全性很高，不过大概在04年的时候被山东大学的王小云破解了；SHA1的安全性最高。
    5. 效率不同，CRC的计算效率很高；MD5和SHA1比较慢。
    6. 用途不同。CRC一般用作通信数据的校验；MD5和SHA1用于安全（Security）领域，比如文件校验、数字签名等。

28、常见问题
    1、依赖包重复的问题
        a.把需要共享的资源打包到一起
        b.分割包，这些包不是在同一时间使用的
        c.把共享部分打成一个单独的包
    2、图集重复问题
        把同一个图集打包到一个AB中
29、StreamingAssets文件夹里的资源都会被打包到安装包里面